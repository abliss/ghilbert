import (PROP ../../prop.ghi () "")
import (PREDICATE ../../predicate/all.ghi (PROP) "")
import (NATURALS common.ghi (PROP PREDICATE) "")
import (INEQUALITY_NAT inequality_nat.ghi (PROP PREDICATE NATURALS) "")
import (HALFMINUS halfminus.ghi (PROP PREDICATE NATURALS) "")
import (SET_MIN ../../set_min.ghi (PROP PREDICATE) "")
import (SET ../../set.ghi (PROP PREDICATE SET_MIN) "")
import (ORDERED_PAIR ../common/ordered-pair.ghi (PROP PREDICATE) "")

tvar (wff ph ps ch th ta et si ph' ps' ch' th' ta')
tvar (nat A B C D A' B' C' D' A0 A1 A2 A3 i j k)
var (nat v w x y z v' w' x' y' z')
tvar (set S T U V)

export (ADD_MULTIPLY_MIN ../common/add_multiply_min.ghi (PROP PREDICATE) "")
import (ADD_MULTIPLY_NAT add_multiply_nat.ghi (PROP PREDICATE ADD_MULTIPLY_MIN) "")

## <title> Substitution </title>
## <table>
##   (-> ph (<->  [ ps ]   ]    ]  th))
##   (<->         [ ps ]   [ ch ] )
##   (-> ph (<->  [    [   [ ch ]  th))
## </table>
thm (BiReplaceImp1Bi0 () (
     replacee (-> ph (<-> ps th))
     substitution (<-> ps ch)) 
     (-> ph (<-> ch th))
  replacee substitution
  th bibi1i
  sylib
)

## <title> Substitution </title>
## <table>
##   (-> ph (<-> ps  [ ch ]   ]    ] ))
##   (<->            [ ch ]   [ th ] )
##   (-> ph (<-> ps  [    [   [ th ] ))
## </table>
thm (BiReplaceImp1Bi1 () (
     replacee (-> ph (<-> ps ch))
     substitution (<-> ch th)) 
     (-> ph (<-> ps th))
  replacee substitution
  ps bibi2i
  sylib
)

## <title> Substitution </title>
## <table>
##   (E. x  [ ph ]   ]    ] )
##   (->    [ ph ]   [ ps ] )
##   (E. x  [    [   [ ps ] )
## </table>
thm (ImpReplaceEx1 () (
     replacee (E. x ph)
     substitution (-> ph ps)) 
     (E. x ps)
  replacee
  substitution
x 19.22i
ax-mp
)


## <context>
##   This theorem is part of a series of theorems that describe the properties
##   of divisibility. It is assumed that every number in this theorem is a natural
##   number.
## </context>

# == Divisibility ==

# number 36.5
thm (df-divides-just ((A x) (B x) (A y) (B y)) ()
       (<-> (E. x (= (* A x) B)) (E. y (= (* A y) B)))
      x y A muleq2 B eqeq1d exalpha)

## <title> Divides Definition </title>
## <suggest> left('Simplify', '|') right('Define', '|') </suggest>
defthm (df-divides wff (| A B) ((A x) (B x)) ()
       (<-> (| A B) (E. x (= (* A x) B)))
        y A B x df-divides-just)

## <title> Equivalence for | </title>
thm (divideseq1 () () (-> (= A C) (<-> (| A B) (| C B)))
  A C x muleq1
  B eqeq1d
  x exbid
  A B x df-divides
  bicomi
  BiReplaceImp1Bi0
  C B x df-divides
  bicomi
  BiReplaceImp1Bi1
)

# Equality inference for the divides relation.
## <title> Equivalence over Divides </title>
## <table>
##   (=      A ]   ]      [ B ]   )
##   (<-> (| A ] C ] ) (| [ B ] C))
## </table>
thm (divideseq1i ()
  (hyp (= A B))
  (<-> (| A C) (| B C))
  hyp A B C divideseq1 ax-mp
)

# Equality inference for the Divides relation.
## <title> Equivalence over divides </title>
## <table>
##  (|    A ] ]   ] [ C)
##     (= A ] [ B ] ] )
##  (|      [ [ B ] [ C)
## </table>
thm (divideseq1ii ()
  (hyp1 (| A C)
   hyp2 (= A B))
  (| B C)
  hyp1 hyp2 C divideseq1i mpbi
)

## <title> Equivalence for | </title>
thm (divideseq2 () () (-> (= B C) (<-> (| A B) (| A C)))
  B C (* A x) eqeq2
  x exbid
  A B x df-divides bicomi
  BiReplaceImp1Bi0
  A C x df-divides bicomi
  BiReplaceImp1Bi1
)


## <title> Equivalence over Divides </title>
## <table>
##   (=        [ A ]      [   [ B ] )
##   (<-> (| C [ A ] ) (| [ C [ B ] ))
## </table>
thm (divideseq2i ()
  (hyp (= A B))
  (<-> (| C A) (| C B))
  hyp A B C divideseq2 ax-mp
)

## <title> Equivalence over Divides </title>
## <table>
##  (| C   [ A ] ] )
##      (= [ A ] [ B)
##  (| C   [   [ [ B)
## </table>
thm (divideseq2ii ()
  (hyp1 (| C A)
   hyp2 (= A B))
  (| C B)
  hyp1 hyp2 C divideseq2i mpbi
)

thm (divideseq1d () (
     hyp1 (-> ph (= A B)))
     (-> ph (<-> (| A C) (| B C)))
  hyp1
  A B C divideseq1
  syl
)

thm (divideseq2d () (
     hyp1 (-> ph (= A B)))
     (-> ph (<-> (| C A) (| C B)))
  hyp1
  A B C divideseq2
  syl
)

## <title> Substitution </title>
## <table>
##   (E. x (= A  [ B ]   ]   ] ))
##   (=          [ B ]   [ C ] )
##   (E. x (= A  [   [   [ C ] ))
## </table>
thm (EqReplaceEx1Eq1 () (
     replacee (E. x (= A B))
     substitution (= B C)) 
     (E. x (= A C))
  replacee
  substitution
A eqeq2i
x exbii
mpbi
)

thm (proveDivides () (hyp (= (* A B) C)) (| A C)
  x B tyex
  x B A muleq2  
  ImpReplaceEx1
  hyp
  EqReplaceEx1Eq1
  A C x df-divides
  
  bicomi
  mpbi
)

thm (proveDividesd () (hyp (-> ph (= (* A B) C))) (-> ph (| A C))
  ph x alnfi
  x B tyex
  x B A muleq2
  C eqeq1d
  ph imbi2d
  ImpReplaceEx1
  hyp
  
  (-> ph (= (* A x) C)) biRemove2
  x exbii
  mpbi
  
  x ph (= (* A x) C) eximp1  
  ax-mp  
  syl
  
  ## <d 'Divides Definition '>
    A C x df-divides
    ## <d 'Commutative Property'>
      (| A C) (E. x (= (* A x) C)) bicom
      mpbi
    ## </d 'Commutative Property'>
    sylib
  ## </d 'Divides Definition '>
)

## <title> Substitution </title>
## <table>
##   (-> ph (A. x  [ ps ]   ]    ] ))
##   (<->          [ ps ]   [ ch ] )
##   (-> ph (A. x  [    [   [ ch ] ))
## </table>
thm (BiReplaceImp1Al1 () (
     replacee (-> ph (A. x ps))
     substitution (<-> ps ch)) 
     (-> ph (A. x ch))
  replacee substitution
  x albii
  sylib
)

## <title> Substitution </title>
## <table>
##   (-> ph (A. x (/\  [ ps ]   ]    ]  th)))
##   (<->              [ ps ]   [ ch ] )
##   (-> ph (A. x (/\  [    [   [ ch ]  th)))
## </table>
thm (BiReplaceImp1Al1An0 () (
     replacee (-> ph (A. x (/\ ps th)))
     substitution (<-> ps ch)) 
     (-> ph (A. x (/\ ch th)))
  replacee substitution
  th anbi1i
  BiReplaceImp1Al1
)


## <title> Substitution </title>
## <table>
##   (-> ph (A. x (/\ (\/ ps  [ ch ]   ]    ] ) ta)))
##   (<->                     [ ch ]   [ th ] )
##   (-> ph (A. x (/\ (\/ ps  [    [   [ th ] ) ta)))
## </table>
thm (BiReplaceImp1Al1An0Or1 () (
     replacee (-> ph (A. x (/\ (\/ ps ch) ta)))
     substitution (<-> ch th)) 
     (-> ph (A. x (/\ (\/ ps th) ta)))
  replacee substitution
  ps orbi2i
  BiReplaceImp1Al1An0
)

## <title> Substitution </title>
## <table>
##   (-> ph (-.  [ ps ]   ]    ] ))
##   (<->        [ ps ]   [ ch ] )
##   (-> ph (-.  [    [   [ ch ] ))
## </table>
thm (BiReplaceImp1Not0 () (
     replacee (-> ph (-. ps))
     substitution (<-> ps ch)) 
     (-> ph (-. ch))
  replacee
  substitution
con4biir
ph imbi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (-> (/\  [ ph ]   ]    ]  ch) th)
##   (<->     [ ph ]   [ ps ] )
##   (-> (/\  [    [   [ ps ]  ch) th)
## </table>
thm (BiReplaceImp0An0 () (
     replacee (-> (/\ ph ch) th)
     substitution (<-> ph ps)) 
     (-> (/\ ps ch) th)
  replacee
  substitution
  ch anbi1i
  th imbi1i
  mpbi
)

## <title> Substitution </title>
## <table>
##   (-> (/\ ph  [ ps ]   ]    ] ) th)
##   (<->        [ ps ]   [ ch ] )
##   (-> (/\ ph  [    [   [ ch ] ) th)
## </table>
thm (BiReplaceImp0An1 () (
     replacee (-> (/\ ph ps) th)
     substitution (<-> ps ch)) 
     (-> (/\ ph ch) th)
  replacee
  substitution
  ph anbi2i
  th imbi1i
  mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> ph (-. (E. x  [ ps ]   ]    ] )))
##   (<->               [ ps ]   [ ch ] )
##   (<-> ph (-. (E. x  [    [   [ ch ] )))
## </table>
thm (BiReplaceBi1Not0Ex1 () (
     replacee (<-> ph (-. (E. x ps)))
     substitution (<-> ps ch)) 
     (<-> ph (-. (E. x ch)))
  replacee
  substitution
x exbii
con4biir
ph bibi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (-> ph (A. x  [ ps ]   ]    ] ))
##   (->           [ ps ]   [ ch ] )
##   (-> ph (A. x  [    [   [ ch ] ))
## </table>
thm (ImpReplaceImp1Al1 () (
     replacee (-> ph (A. x ps))
     substitution (-> ps ch)) 
     (-> ph (A. x ch))
  replacee substitution
  x 19.20i
  syl
)

thm (notDivides () ()  (-> (/\ (< (* A C) B) (< B (* A (+ C (1))))) (-. (| A B)))
  (/\ (< (* A C) B) (< B (* A (+ C (1))))) x alnfi
  (<= x C) exmid
  (/\ (< (* A C) B) (< B (* A (+ C (1))))) anRemove1
  ## <d 'Commutative Property '>
    (/\ (\/ (<= x C) (-. (<= x C))) (/\ (< (* A C) B) (< B (* A (+ C (1)))))) (/\ (< (* A C) B) (< B (* A (+ C (1))))) bicom
    mpbi
  ## </d 'Commutative Property '>
  x albii
  sylib
  
  ## <d 'Def. Greater Than '>
    x C df-gt
    ## <d 'Commutative Property'>
      (> x C) (-. (<= x C)) bicom
      mpbi
    ## </d 'Commutative Property'>
    BiReplaceImp1Al1An0Or1
  ## </d 'Def. Greater Than '>

  x C A lemul2nat
  (< (* A C) B) anim1i
  (* A x) (* A C) B lelttr
  syl
  (* A x) B ltneq
  syl
  (< B (* A (+ C (1)))) adantr
  ## <d>
    (<= x C) (< (* A C) B) (< B (* A (+ C (1)))) anass
  ## </d>
  sylbi2

  (+ C (1)) x A lemul2nat
  (< B (* A (+ C (1))) ) anim2i

  B (* A (+ C (1))) (* A x) ltletr
  syl
  B (* A x) ltneq

  ## <d>
    B (* A x) eqcom
  ## </d>
  BiReplaceImp1Not0
  syl

  ## <d>
    (< B (* A (+ C (1)))) (<= (+ C (1)) x) ancom
  ## </d>
  sylbi2

  ## <d>
    (+ C (1)) x lecon
  ## </d>
  BiReplaceImp0An0
  C x nnltp1let

  ## <d>
    (+ C (1)) x lecon
  ## </d>
  bitri
  ## <d>
    C x ltcon
  ## </d>
  bitr3icom
  ## <d>
    bicomi
  ## </d>
  BiReplaceImp0An0

  (< (* A C) B) adantr
  ## <d>
    (> x C) (< B (* A (+ C (1)))) (< (* A C) B) anass
  ## </d>
  sylbi2

  ## <d>
    (< B (* A (+ C (1)))) (< (* A C) B) ancom
  ## </d>
  BiReplaceImp0An1
  jaoi
  (<= x C) (> x C) (/\ (< (* A C) B) (< B (* A (+ C (1))))) andir
  ## <d>
    bicomi
  ## </d>
  sylbi2

  ImpReplaceImp1Al1

  ## <d>
    x (-. (= (* A x) B)) alex
    (= (* A x) B) notnotr
    BiReplaceBi1Not0Ex1
    sylib
  ## </d>
  ## <d 'Divides Definition '>
    A B x df-divides
    ## <d 'Commutative Property'>
      (| A B) (E. x (= (* A x) B)) bicom
      mpbi
    ## </d 'Commutative Property'>
    BiReplaceImp1Not0
  ## </d 'Divides Definition '>
)

## <title> A number divides itself </title>
## <suggest> full('Simplify', 'T') </suggest>
thm (dividessym () () (| A A)
    x (1) tyex
    x (1) A muleq2  eqcomd  A mulid  eqcomi syl5eq   eqcomd  x 19.22i
  ax-mp
  A A x df-divides
  mpbir
)

# number 46.0
thm (dividesmul () () (-> (| A B) (| A (* B C)))
  A B x df-divides biimpi

   y (* x C) tyex
   y (* x C) A muleq2   y 19.22i
  ax-mp

  (* A x) B C muleq1
  A x C mulass  syl5eqr
  (* A y) eqeq2d
  biimpd

  y 19.21ai    y (= (* A y) (* A (* x C))) (= (* A y) (* B C)) 19.22 syl

  mpi
  x 19.22i syl
  x (E. y (= (* A y) (* B C))) 19.9   biimpi  syl

  A (* B C) y df-divides   biimpri   syl
)

thm (dividesmuli () (hyp (| A B)) (| A (* B C))
  hyp
  A B C dividesmul  
  ax-mp
)



## <title> One-digit Addition </title>
thm (1plus1 () () (= (+ (1) (1)) (2))
  df-2
  ## <d 'Commutative Property'>
    (2) (+ (1) (1)) eqcom
    mpbi
  ## </d 'Commutative Property'>
)

## <title> Substitution </title>
## <table>
##   (>  [ A ]   ]   ]  C)
##   (=  [ A ]   [ B ] )
##   (>  [   [   [ B ]  C)
## </table>
thm (EqReplaceGt0 () (
     replacee (> A C)
     substitution (= A B)) 
     (> B C)
  replacee substitution
  C gteq1i
  mpbi
)

## <title> Substitution </title>
## <table>
##   (> A  [ B ]   ]   ] )
##   (=    [ B ]   [ C ] )
##   (> A  [   [   [ C ] )
## </table>
thm (EqReplaceGt1 () (
     replacee (> A B)
     substitution (= B C)) 
     (> A C)
  replacee substitution
  A gteq2i
  mpbi
)

## <title> One-Digit Inequality </title>
thm (2greater1 () () (> (2) (1))
  ## <d 'Add To Both Sides'>
    ## <d 'Derive Smaller Inequality'>
      1greater0
    ## </d 'Derive Smaller Inequality'>
    ## <d 'Add To Both Sides'>
      (1) gtadd2i
    ## </d 'Add To Both Sides'>
    ## <d 'Simplify Left Side'>
      1plus1
      EqReplaceGt0
    ## </d 'Simplify Left Side'>
    ## <d 'Simplify Right Side'>
      (1) addid
      EqReplaceGt1
    ## </d 'Simplify Right Side'>
  ## </d 'Add To Both Sides'>
)

thm (add2greater1 () () (> (+ A (2)) (1))
  (2) A addge02t  
  ## <d 'Converse of ≤ '>
    (2) (+ A (2)) lecon
    mpbi
  ## </d 'Converse of ≤ '>
  2greater1
  pm3.2i
  (+ A (2)) (2) (1) gegttr  
  ax-mp
)

thm (dividesadd.1 () () (-> (| (+ A (1)) (+ (* (+ A (1)) B) C)) (| (+ A (1)) C))
    (+ A (1))  (+ (* (+ A (1)) B) C)  x  df-divides    biimpi
        (* (+ A (1)) B)  C  addge01t
        ( = (* (+ A (1)) x) (+ (* (+ A (1)) B) C))  id  (* (+ A (1)) B)  leeq2d    biimprd    mpi
        (+ A (1))  B  mulcom    (* (+ A (1)) x)  leeq1i    sylib
        (+ A (1))  x  mulcom    (* B (+ A (1)))  leeq2i    sylib
        B  A  x  lemul5 biimpi    syl
        B  x  y  df-le    sylib
        (+ B y)  x  (+ A (1))  muleq2    eqcomd   y  19.22i    syl
        ancri
        y  (= (* (+ A (1)) x) (* (+ A (1)) (+ B y)))  (= (* (+ A (1)) x) (+ (* (+ A (1)) B) C))  19.41    sylibr
          (* (+ A (1)) x)  (* (+ A (1)) (+ B y))  (+ (* (+ A (1)) B) C)  eqtr2
          (+ A (1))  B  y  distr    (+ (* (+ A (1)) B) C)  eqeq1i    sylib
          (* (+ A (1)) B)  (* (+ A (1)) y)  C  addcan2    biimpi    syl

        y  19.22i    syl
        (+ A (1))  C  y  df-divides    sylibr

    x  19.22i   syl    x  (| (+ A (1)) C) 19.9    sylib
)

thm (divides1 () () (-. (| (+ A (2)) (1)))
  A add2greater1
    (+ A (2))  (1)  x  df-divides    biimpi
        x  z  lefoo
          0ne1
            x  (0)  (+ A (2))  muleq2    (+ A (2)) mul0    syl6eq
            (1) eqeq1d    biimpd    con3d
          mpi    (E. z (= (+ (1) z) x))  orim1i
        ax-mp
        (= (* (+ A (2)) x) (1))  (E. z (= (+ (1) z) x))  imor    biimpri    ax-mp
        ancli
        (+ (1) z)  x  (+ A (2)) muleq2    (1)  eqeq1d    biimprd    z  19.22i    (= (* (+ A (2)) x) (1))  anim2i    syl
        ancomd    z  (-> (= (* (+ A (2)) x) (1)) (= (* (+ A (2)) (+ (1) z)) (1)))  (= (* (+ A (2)) x) (1))  19.41    sylibr
        (= (* (+ A (2)) x) (1))  (= (* (+ A (2)) (+ (1) z)) (1))  pm3.35    ancoms    z  19.22i    syl
    x  19.22i    syl    x  (E. z (= (* (+ A (2)) (+ (1) z)) (1)))  19.9    sylib
      x  (* (+ A (2)) z) tyex
       x  (* (+ A (2)) z)  (+ A (2)) addeq2    (1)  eqeq1d    biimprd
        (+ A (2))  (1)  z  distr    (1)  eqeq1i   biimpi
        (+ A (2))  mulid    (* (+ A (2)) z)  addeq1i      syl5eqr
       syl5com
      x  19.22d    mpi
      (+ A (2))  (1)  x  df-le    biimpri    syl
    z  19.22i    syl    z  (<= (+ A (2)) (1)) 19.9    sylib
    con3i
    ## <d 'Def. Greater Than '>
      (+ A (2)) (1) df-gt bicomi
      sylbi2
    ## </d 'Def. Greater Than '>
  ax-mp
)

# number 128.6
thm (dividesmul12 () () (-> (| A B) (| (* A C) (* B C)))
  A  B  x  df-divides
    (* A x)  B  C  muleq1
      A  x  C  mulass    x  C  mulcom  (* x C)  (* C x)  A  muleq2  ax-mp  eqtri
      A  C  x  mulass  eqtr4 (* B C)  eqeq1i  sylib
    x  19.22i  sylbi
  (* A C)  (* B C)  x  df-divides  sylibr
)

## <title> Divides relation is transitive </title>
thm (dividestr () () (-> (/\ (| A B) (| B C)) (| A C))
    A  B  x  df-divides    biimpi
        B  C  y  df-divides    biimpi
    anim12i
    x  (= (* A x) B)  (E. y (= (* B y) C))  19.41    sylibr
    y  (= (* B y) C)  (= (* A x) B)  19.41    biimpri    ancoms    x 19.22i    syl
        (* A x)  B  y  muleq1     C  eqeq1d    biimprd
        (= (* A x) B)  (= (* B y) C)  (= (* (* A x) y) C)  pm3.31    ax-mp
        ancoms A  x  y  mulass    syl5eqr    z 19.21ai
            z  (* x y)  tyex
            z  (* x y)  A  muleq2    C  eqeq1d    biimprd    z  19.22i    ax-mp
            z  (= (* A (* x y)) C)  (= (* A z) C)  eximp1    ax-mp
        syl
    y  19.22i    x  19.22i    syl
    19.9d    19.9d
    A  C  z  df-divides    sylibr
)


## <context>
##   This theorem is part of a series of theorems that describe the properties
##   of the minimum number in a set of natural numbers. It is assumed that every
##   number in this theorem is a natural number.
## </context>

# number 87.0
thm (df-min-just ((S x) (S y) (S x') (S y')) ()
  (= (iota ({|} x (/\ (e. x S) (A. y (-> (e. y S) (<= x y))))))
     (iota ({|} x' (/\ (e. x' S) (A. y' (-> (e. y' S) (<= x' y')))))))
x  x'  S  ax-eleq1
  (= x x')  id    y  leeq1d    (e. y S)  imbi2d   y  19.21ai
  y  (-> (e. y S) (<= x y))  (-> (e. y S) (<= x' y))  19.15    syl
    y  y'  S  ax-eleq1
      (= y y')  id    x'  leeq2d
    imbi12d   alpha
  syl6bb
  anbi12d
  abeq
  ({|} x (/\ (e. x S) (A. y (-> (e. y S) (<= x y)))))  ({|} x' (/\ (e. x' S) (A. y' (-> (e. y' S) (<= x' y')))))    ax-iotaeq    ax-mp
)

defthm  (df-min nat (min S) ((S x) (S y)) ()
        (= (min S) (iota ({|} x (/\ (e. x S) (A. y (-> (e. y S) (<= x y)))))))
          x' S y' x y df-min-just)

# number 88.0
## <table>
##   (-> (=_ <r> S <g> T) (= (min <r> S) (min <g> T)))
## </table>
thm (minseq () () (-> (=_ S T) (= (min S) (min T)))
  S  T  x  df-seq    biimpi    x  (<-> (e. x S) (e. x T))  ax-4    syl
    S  T  y  df-seq    biimpi    y  (<-> (e. y S) (e. y T))  ax-4    syl
    (<= x y)  imbi1d
    y  19.21ai
    19.15d
  anbi12d
  x  19.21ai
  x  (/\ (e. x S) (A. y (-> (e. y S) (<= x y))))  (/\ (e. x T) (A. y (-> (e. y T) (<= x y))))  abbi2    syl
  ({|} x (/\ (e. x S) (A. y (-> (e. y S) (<= x y)))))  ({|} x (/\ (e. x T) (A. y (-> (e. y T) (<= x y)))))  ax-iotaeq    syl

  S  x  y  df-min    syl5eq
  T  x  y  df-min    syl6eqr
)

thm (minseqi () (hyp (=_ S T)) (= (min S) (min T))
  hyp
  S T minseq
  ax-mp
)

thm (minex.1 () ()
  (-> (= y A)
    (<->
      (-> (e. y S) (/\ (e. (min S) S)
                                (<= (min S) y)))
      (-> (e. A S) (/\ (e. (min S) S)
                                 (<= (min S) A)))))

y  A  S  ax-eleq1
  (= y A)  id    (min S)  leeq2d    (e. (min S) S) anbi2d
  imbi12d
)

# number 102.0
thm (minex.2.1 ((A w) (S w) (B w)) ()
  (-> (/\ (e. B S) (A. w (-> (e. w S) (<= A w)))) (<= A B))

w  (e. B S)  (-> (e. w S) (<= A w))  alan1    biimpri

w  B  tyex

  B  w  S ax-eleq1
    (= B w) id    A leeq2d
  imbi12d
  eqcoms
  biimprd
  imp3a
  ancomsd
w  19.22i    ax-mp
w  (/\ (e. B S) (-> (e. w S) (<= A w)))  (<= A B)  eximp1    ax-mp

syl
w  (<= A B)  ex-nf   syl
)

thm (minex.2.2 ((S w) (A w)) () (-> (/\ (e. A S) (A. w (-> (e. w S) (<= A w)))) (= A (min S)))
    x  A  S  ax-eleq1
      (= x A)  id    w  leeq1d    (e. w S)  imbi2d   w  19.21ai
      w  (-> (e. w S) (<= x w))  (-> (e. w S) (<= A w))  19.15    syl
    anbi12d    biimprcd
      (e. A S)  (A. w (-> (e. w S) (<= A w)))  ancom  (/\ (e. x S) (A. w (-> (e. w S) (<= x w))))  anbi2i (e. x S)  (A. w (-> (e. w S) (<= x w)))  (A. w (-> (e. w S) (<= A w)))  (e. A S)  an4    bitri       biimpi
      A  S  w x minex.2.1   ancoms    (/\ (e. x S) (A. w (-> (e. w S) (<= A w))))  anim2i   syl
      x  S  w A minex.2.1  (<= x A)  anim1i    syl
      A  x  lesym   sylibr    eqcomd       expcom
    impbid

    x  19.21ai
    x  (= x A)  (/\ (e. x S) (A. w (-> (e. w S) (<= x w))))  abbi2    syl
    ({|} x (= x A))  ({|} x (/\ (e. x S) (A. w (-> (e. w S) (<= x w)))))  ax-iotaeq    syl
    S  x  w  df-min     syl6eqr
    A x  df-sn  ({} A)  ({|} x (= x A))  ax-iotaeq    ax-mp       syl5eq
    A  ax-iota    syl5eqr
)

thm (minex2.2 ((S w)) () (-> (/\ (e. w' S) (A. w (-> (e. w S) (<= w' w)))) (= w' (min S)))
    x  w'  S  ax-eleq1
      (= x w')  id    w  leeq1d    (e. w S)  imbi2d   w  19.21ai
      w  (-> (e. w S) (<= x w))  (-> (e. w S) (<= w' w))  19.15    syl
    anbi12d    biimprcd
      (e. w' S)  (A. w (-> (e. w S) (<= w' w)))  ancom  (/\ (e. x S) (A. w (-> (e. w S) (<= x w))))  anbi2i (e. x S)  (A. w (-> (e. w S) (<= x w)))  (A. w (-> (e. w S) (<= w' w)))  (e. w' S)  an4    bitri       biimpi
      w'  S  w x minex.2.1   ancoms    (/\ (e. x S) (A. w (-> (e. w S) (<= w' w))))  anim2i   syl
      x  S  w w' minex.2.1  (<= x w')  anim1i    syl
      w'  x  lesym   sylibr    eqcomd       expcom
    impbid

    x  19.21ai
    x  (= x w')  (/\ (e. x S) (A. w (-> (e. w S) (<= x w))))  abbi2    syl
    ({|} x (= x w'))  ({|} x (/\ (e. x S) (A. w (-> (e. w S) (<= x w)))))  ax-iotaeq    syl
    S  x  w  df-min     syl6eqr
    w' x  df-sn  ({} w')  ({|} x (= x w'))  ax-iotaeq    ax-mp       syl5eq
    w'  ax-iota    syl5eqr
)

thm (minex.2 ((S w)) ()
    (-> (A. w (-> (<= w z)
      (-> (e. w S) (/\ (e. (min S) S)
                                (<= (min S) w)))))
      (-> (e. (+ z (1)) S) (/\ (e. (min S) S)
                                (<= (min S) (+ z (1))))))
### Please excuse this bit of time-travel.
(<= w z) (e. w S)  (/\ (e. (min S) S) (<= (min S) w))  imdistan  biimpi
  (<= w z)  (/\ (e. (min S) S) (<= (min S) w))  ancom  biimpi z  (1)  addge01t
w  z  (+ z (1))  letr  ancoms  mpan  (/\ (e. (min S) S) (<= (min S) w))  anim2i  syl  syl6  ancomsd
w 19.20i
###


# Case 1:  z' is in fact  min S.  This one is easy.
#  S  y  z  df-min    (+ z (1))  eqeq2i    biimpi  (e. (+ z (1)) S)  a1d
(+ z (1))  (min S)  S  ax-eleq1  biimpd
    (+ z (1))  leid    (= (+ z (1)) (min S)) id  (+ z (1))  leeq1d    mpbii    (e. (+ z (1)) S)  a1d
jcad
# Tack this on for later
(-> (e. (+ z (1)) S) (E. w (/\ (e. w S) (<= w z))))  orcd

# Case 2: z' is in S but NOT the min.
# What follows would be a lot more readable without all the mandhyps!
  S  x  w  df-min  (+ z (1))  eqeq2i  notbii   biimpi
  ({|} x (/\ (e. x S) (A. w (-> (e. w S) (<= x w)))))  ({} (+ z (1)))  ax-iotaeq    (+ z (1))  ax-iota   syl6eq   eqcomd   con3i    syl
  ({|} x (/\ (e. x S) (A. w (-> (e. w S) (<= x w)))))  ({} (+ z (1)))  w'  df-seq  notbii    biimpi   syl
  (<-> (e. w' ({|} x (/\ (e. x S) (A. w (-> (e. w S) (<= x w)))))) (e. w' ({} (+ z (1)))))  notnot    biimpri    w'  19.20i   con3i    syl
  w'  (-. (<-> (e. w' ({|} x (/\ (e. x S) (A. w (-> (e. w S) (<= x w)))))) (e. w' ({} (+ z (1))))))  df-ex    biimpri    syl
  w'  (+ z (1))  elsnc    (e. w' ({|} x (/\ (e. x S) (A. w (-> (e. w S) (<= x w))))))  bibi2i    notbii   w'  exbii    sylib
    x  w'  S   ax-eleq1
      (= x  w')  id    w  leeq1d    (e. w S)  imbi2d     w  19.21ai    w  (-> (e. w S) (<= x w))  (-> (e. w S) (<= w' w)) 19.15   syl
  anbi12d    elab    (= w' (+ z (1)))  bibi1i    notbii  w'  exbii  sylib
  (/\ (e. w' S) (A. w (-> (e. w S) (<= w' w))))  (= w' (+ z (1)))  xor     w'  exbii    sylib
    # We now have z' != min S -> (case A) \/ (case B).  Let's reduce case B to something we like.
    w'  (+ z (1))  S  ax-eleq1
      (= w' (+ z (1)))  id  w  leeq1d   (e. w S)  imbi2d     w  19.21ai    19.15d       anbi12d    notbid  biimpd
      (e. (+ z (1)) S)  (A. w (-> (e. w S) (<= (+ z (1)) w)))  pm3.13    syl6   imp
      (e. (+ z (1)) S)  (-. (A. w (-> (e. w S) (<= (+ z (1)) w))))  imor    sylibr
        (-> (e. w S) (<= (+ z (1)) w))  notnot2  w  19.20i  con3i  w  (-. (-> (e. w S) (<= (+ z (1)) w)))  df-ex      sylibr
        (e. w S)  (<= (+ z (1)) w)  pm4.61    biimpi  (+ z (1))  w  lecon  w (+ z (1)) df-ge bitri
       con2bii    biimpri   w  z  lePlus1    sylib  (e. w S)  anim2i    syl   w  19.22i    syl
      syl6
    (/\ (/\ (e. w' S) (A. w (-> (e. w S) (<= w' w)))) (-. (= w' (+ z (1)))))  orim2i    w'  19.22i       w'  (/\ (/\ (e. w' S) (A. w (-> (e. w S) (<= w' w)))) (-. (= w' (+ z (1)))))  (-> (e. (+ z (1)) S) (E. w (/\ (e. w S) (<= w z))))  exor2    sylib  syl
    # Okay, now let's work with case A.  First show that w' is in fact min S.
    w'  S  w  minex.2.2
    # Ok, now work out the consequences of w' = min S
    (/\ (e. w' S) (A. w (-> (e. w S) (<= w' w))))  (= w' (min S))  anidmdbi    mpbir
    (e. w' S)  (A. w (-> (e. w S) (<= w' w)))  (/\ (= w' (min S)) (= w' (min S)))  pm5.3    mpbi
    (e. w' S)  (= w' (min S))  (= w' (min S))  anass    sylibr
    w'  (min S)  S ax-eleq1   biimpac    (= w' (min S))  anim1i    syl
    pm4.71ri  biimpi   (e. w' S)  (A. w (-> (e. w S) (<= w' w)))  pm3.27   (/\ (e. (min S) S) (= w' (min S)))  anim2i      syl
    (e. (min S) S)  (= w' (min S))  (A. w (-> (e. w S) (<= w' w)))  anass  sylib
      (= w' (min S))  id    w leeq1d  (e. w S)  imbi2d    w  19.21ai    19.15d    biimpd   imp
    (+ z (1)) S  w  (min S)  minex.2.1     impexpi    syl       (e. (min S) S)  anim2i    syl
    (e. (min S) S)  (e. (+ z (1)) S)  (<= (min S) (+ z (1)))  anim3  syl
  (-. (= w' (+ z (1)))) adantr   w'  exani   (-> (e. (+ z (1)) S) (E. w (/\ (e. w S) (<= w z))))  orim1i  syl

# Great, now we can join up the two cases!
pm2.61i
# Pull out the common hypothesis
(e. (+ z (1)) S)  (/\ (e. (min S) S) (<= (min S) (+ z (1))))  (E. w (/\ (e. w S) (<= w z)))  pm4.78    mpbi

# Almost there; just need to apply the IHOP to case 2B.

# Introduce the new antecedent and polish up the new conclusion
  w  (/\ (e. w S) (<= w z))  (/\ (/\ (e. (min S) S) (<= (min S) w)) (<= w (+ z (1)))) 19.22
    (e. (min S) S)  (<= (min S) w)  (<= w (+ z (1)))  anass     (min S)  w  (+ z (1))  letr   (e. (min S) S)  anim2i    sylbi  w 19.22i
    w  (/\ (e. (min S) S) (<= (min S) (+ z (1))))  ex-nf  syl
  syl6
(/\ (e. (min S) S) (<= (min S) (+ z (1))))  orim2d     mpan9
(/\ (e. (min S) S) (<= (min S) (+ z (1))))  pm1.2    syl
impexpi

syl
)

## <title> The minimum of a nonempty set exists </title>
thm (minex () ()     (-> (e. A S) (/\ (e. (min S) S)
                                (<= (min S) A)))
  x  (0)  S  minex.1
    x  (+ y (1))  S  minex.1
      x  A  S  minex.1
        (0)  x  addge01t x  addidr    (0)  leeq2i    mpbi  (e. x S)  a1i   x  gen
        (0)  S  x  minex.2.2  ancoms  mpan
          (0)  (min S)  S  ax-eleq1  biimpd    com12                a2i
            (0)  leid    (= (0) (min S))  id   (0) leeq1d  mpbii    (e. (0) S) imim2i
        jcad    ax-mp
          x  y  S  minex.2
  sind
)

# Equality deduction for set minimum
thm (minseqd () (h (-> ph (=_ S T)))
  (-> ph (= (min S) (min T)))
  h S T minseq syl
)

## <context>
##   This theorem is part of a series of theorems that describe the properties
##   of the modulo operation. It is assumed that every
##   number in this theorem is a natural number.
## </context>

# number 89.0
thm (df-mod-just ((A x y x' y') (B x y x' y')) ()
  (= (min ({|} x (E. y (= (+ (* B y) x) A))))
     (min ({|} x' (E. y' (= (+ (* B y') x') A)))))
  x  x'  (* B y)  addeq2    A  eqeq1d     y  exbid
    y  y'  B  muleq2    x'  addeq1d    A  eqeq1d    exalpha
  syl6bb
  abeq
  ({|} x (E. y (= (+ (* B y) x) A)))  ({|} x' (E. y' (= (+ (* B y') x') A)))  minseq    ax-mp
)


defthm  (df-mod nat (mod A B) ((A x y) (B x y)) ()
        (= (mod A B) (min ({|} x (E. y (= (+ (* B y) x) A)))))
          x'  y'  B  A  x  y df-mod-just)

thm (modeq1 () () (-> (= A B) (= (mod A C) (mod B C)))
  A B (+ (* C y) x) eqeq2 y exbid
  x abbi2d minseqd
    A C x y df-mod
      B C x y df-mod
  3eqtr4g
)

# Equality theorem for mod
thm (modeq2 () () (-> (= A B) (= (mod C A) (mod C B)))
  A  B  y  muleq1  x  addeq1d   C  eqeq1d   y  exbid x  19.21ai
  x  (E. y (= (+ (* A y) x) C))  (E. y (= (+ (* B y) x) C))  abbi2  syl
  ({|} x (E. y (= (+ (* A y) x) C)))  ({|} x (E. y (= (+ (* B y) x) C)))  minseq  syl
  C  A  x  y  df-mod  syl5eq
  C  B  x  y  df-mod  syl6eqr
)

thm (modeq1i () (
     hyp1 (= A B))
     (= (mod A C) (mod B C))
  hyp1
  A B C modeq1
  ax-mp
)

thm (modeq1d () (
     hyp1 (-> ph (= A B)))
     (-> ph (= (mod A C) (mod B C)))
  hyp1
  A B C modeq1
  syl
)

thm (modeq2i () (
     hyp1 (= A B))
     (= (mod C A) (mod C B))
  hyp1
  A B C modeq2
  ax-mp
)

thm (modeq2d () (
     hyp1 (-> ph (= A B)))
     (-> ph (= (mod C A) (mod C B)))
  hyp1
  A B C modeq2
  syl
)

## <title> Substitution </title>
## <table>
##   (-> ph (= A  [ B ]   ]   ] ))
##   (=           [ B ]   [ C ] )
##   (-> ph (= A  [   [   [ C ] ))
## </table>
thm (EqReplaceImp1Eq1 () (
     replacee (-> ph (= A B))
     substitution (= B C)) 
     (-> ph (= A C))
  replacee substitution
  A eqeq2i
  sylib
)

## <title> Substitution </title>
## <table>
##   (-> ph (= A (+  [ B ]   ]   ]  D)))
##   (=              [ B ]   [ C ] )
##   (-> ph (= A (+  [   [   [ C ]  D)))
## </table>
thm (EqReplaceImp1Eq1Add0 () (
     replacee (-> ph (= A (+ B D)))
     substitution (= B C)) 
     (-> ph (= A (+ C D)))
  replacee substitution
  D addeq1i
  EqReplaceImp1Eq1
)

## <context>
##   This theorem is part of a series of theorems that describe the properties
##   of the minimum number in a set of natural numbers. It is assumed that every
##   number in this theorem is a natural number.
## </context>

## <title> A nonempty set minimum is in the set </title>
thm (mincl ((S x)) ()
  (-> (E. x (e. x S)) (e. (min S) S))
  x S minex pm3.26d x 19.23ai
)

thm (minsn () () (= (min ({} A)) A)
  x ({} A) mincl
  (min ({} A)) A elsnc
  sylib
  x A tyex
  x A ({} A) ax-eleq1  
  ImpReplaceEx1
  A A elsnc
  A eqid  
  mpbirRemove  
  (e. x ({} A)) biRemove2
  x exbii
  mpbi  
  ax-mpRemove
)

## <title> Substitution </title>
## <table>
##   (=_ S  [ T ]   ]   ] )
##   (=_    [ T ]   [ U ] )
##   (=_ S  [   [   [ U ] )
## </table>
thm (SeqReplaceSeq1 () (
     replacee (=_ S T)
     substitution (=_ T U)) 
     (=_ S U)
  replacee
  substitution
S seqseq2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (<  [ A ]   ]   ]  C)
##   (=  [ A ]   [ B ] )
##   (<  [   [   [ B ]  C)
## </table>
thm (EqReplaceLt0 () (
     replacee (< A C)
     substitution (= A B)) 
     (< B C)
  replacee substitution
  C lteq1i
  mpbi
)

## <context>
##   This theorem is part of a series of theorems that describe the properties
##   of the modulo operation. It is assumed that every
##   number in this theorem is a natural number.
## </context>

thm (mod0 () () (= (mod A (0)) A)
  A (0) x y df-mod
  x z (* (0) y) addeq2  
  ## <d 'Multiply by 0 '>
  ## <d 'Multiply by 0 '>
    y mul0r
    EqReplaceImp1Eq1Add0
  ## </d 'Multiply by 0 '>  
  ## <d 'Additive Identity '>
    z addidr
    EqReplaceImp1Eq1
  ## </d 'Additive Identity '>
  ## <d 'Multiply by 0 '>
  A eqeq1d
  y exbid  
  ## <d 'Quantified Non-free Variable '>
    y (= z A) 19.9
    BiReplaceImp1Bi1
  ## </d 'Quantified Non-free Variable '>
  abeq  
  ## <d>
    A z df-sn seqcomi
    SeqReplaceSeq1
  ## </d>
  minseqi
  EqReplaceEq1
  A minsn  
  EqReplaceEq1
)


## <title> Substitution </title>
## <table>
##   (< (mod A  [ B ]   ]   ] ) D)
##   (=         [ B ]   [ C ] )
##   (< (mod A  [   [   [ C ] ) D)
## </table>
thm (EqReplaceLt0Mod1 () (
     replacee (< (mod A B) D)
     substitution (= B C)) 
     (< (mod A C) D)
  replacee substitution
  A modeq2i
  EqReplaceLt0
)

thm (modval.1 () ()
  (-> (/\ (= (+ (* (+ B (1)) D) C) A) (= (+ (* (+ B (1)) D') C') A))
   (<-> (< D' D) (< C C')))

  (+ (* (+ B (1)) D) C) A eqcom (+ (* (+ B (1)) D') C') A eqcom anbi12i
  A (+ (* (+ B (1)) D) C) (+ (* (+ B (1)) D') C') eqtr2 sylbi

  (* (+ B (1)) D) C (* (+ B (1)) D') C' leadd12 syl

    (+ B (1)) D mulcom (* (+ B (1)) D') leeq1i
    (+ B (1)) D' mulcom (* D (+ B (1))) leeq2i bitri
    D B D' lemul5 bitri
  syl5bbr
  ## <d 'Negate Both Sides '>
    (<= D D') (<= C' C) notbi
    sylib
  ## </d 'Negate Both Sides '>
  ## <d 'Def. Greater Than '>
    D D' df-gt bicomi
    BiReplaceImp1Bi0
  ## </d 'Def. Greater Than '>
  ## <d 'Converse of < '>
    D' D ltcon bicomi
    BiReplaceImp1Bi0
  ## </d 'Converse of < '>
  ## <d 'Def. Greater Than '>
    C' C df-gt bicomi
    BiReplaceImp1Bi1
  ## </d 'Def. Greater Than '>
  ## <d 'Converse of < '>
    C C' ltcon bicomi
    BiReplaceImp1Bi1
  ## </d 'Converse of < '>
)

thm (modval.2 () ()
  (-> (/\ (= (+ (* (+ B (1)) D) C) A) (= (+ (* (+ B (1)) D') C') A))
    (-> (< C C') (<= (+ (+ B (1)) C) C')))
  B D C A D' C' modval.1
  biimprd
  D' D nnltp1let syl6ib

  (+ D' (1)) D (+ B (1)) lemul2 (+ B (1)) 0le  
  (<= (+ D' (1)) D) anRemove2
  (<= (* (+ B (1)) (+ D' (1))) (* (+ B (1)) D)) imbi1i
  mpbi
  syl6

    (+ B (1)) D' (1) distr
    (+ B (1)) mulid (* (+ B (1)) D') addeq2i eqtri
    (* (+ B (1)) D) leeq1i
  syl6ib
  #(* (+ B (1)) D) addid (+ (* (+ B (1)) D') (+ B (1))) leeq2i syl6ibr
  #(+ B (1)) (0) (* (+ B (1)) D') leadd2 syl6ibr

  (+ (* (+ B (1)) D') (+ B (1))) (* (+ B (1)) D) C leadd1 syl6ib

    # Note: the next two lines are copied from modval.1, should be refactored
    (+ (* (+ B (1)) D) C) A eqcom (+ (* (+ B (1)) D') C') A eqcom anbi12i
    A (+ (* (+ B (1)) D) C) (+ (* (+ B (1)) D') C') eqtr2 sylbi
    (+ (+ (* (+ B (1)) D') (+ B (1))) C) leeq2d
  sylibd

  (* (+ B (1)) D') (+ B (1)) C addass (+ (* (+ B (1)) D') C') leeq1i syl6ib
  (+ (+ B (1)) C) C' (* (+ B (1)) D') leadd2 syl6ibr
)

thm (modval.3 () ()
  (-> (/\ (= (+ (* B D) C) A) (= (+ (* B D') C') A)) (-> (< C C') (<= (+ B C) C')))
    (0) B C addeq1 C addidr syl5eqr C' leeq1d
    C C' df-lt pm3.26bi syl5bi
    (/\ (= (+ (* B D) C) A) (= (+ (* B D') C') A)) a1d
  (0) B eqcom B eq0le0 bitri B (0) lecon (0) B df-ge bitri
  bitri con2bii
  (0) B nnltp1let (1) addidr B leeq1i bitri
  bitr3i

  (.- B (1)) D C A D' C' modval.2

  (1) B halfminus D muleq1d C addeq1d A eqeq1d
    (1) B halfminus D' muleq1d C' addeq1d A eqeq1d
  anbi12d

  (1) B halfminus C addeq1d C' leeq1d
  (< C C') imbi2d
  imbi12d
  mpbii
  sylbi

  pm2.61i
)

## <context>
##   This theorem is part of a series of theorems that describe the properties
##   of the minimum number in a set of natural numbers. It is assumed that every
##   number in this theorem is a natural number.
## </context>

## <summary> Another way of specifying the value of minimum </summary>
thm (minval ((ps x) (A x))
  (h1 (rwff x ph)
   h2 (-> (= x A) (<-> ph ps)))
  (-> (/\ ps (A. x (-> ph (<= A x)))) (= A (min ({|} x ph))))

  h2 elab
  A ({|} x ph) minex sylbir
    x (min ({|} x ph)) ({|} x ph) ax-eleq1
    h1 abid syl5bbr
      (= x (min ({|} x ph))) id A leeq2d
    imbi12d
    cla4g
  anim12i
    (e. (min ({|} x ph)) ({|} x ph)) (<= A (min ({|} x ph))) pm3.35
    (<= (min ({|} x ph)) A) anim1i
    an1rs
  syl
  A (min ({|} x ph)) lesym sylibr
)

## <suggest> right('Simplify', 'min') </suggest>
thm (minsetval ((S x) (A x)) () (-> (/\ (e. A S) (A. x (-> (e. x S) (<= A x)))) (= A (min ({|} x (e. x S)))))
  x y S ax-eleq1
  rwffi
  x A S ax-eleq1
  minval
)

## <summary> If any number satisfies a predicate, the minimum does </summary>
thm (minel ((ps x)) (
  h1 (rwff x ph)
  h2 (-> (= x (min ({|} x ph))) (<-> ph ps))
  ) (-> (E. x ph) ps)

  h1 abid x exbii
  x ({|} x ph) mincl sylbir
  h2 elab sylib
)



## <summary>
##   Combines <a href="minsn">minsn</a> and <a href="snid">snid</a> into the form
##   <a href="minun">minun</a> expects.
## </summary>
thm (minsn2 () () (/\ (= A (min ({} A))) (e. A ({} A)))
  A minsn
  eqcomi
  A snid
  pm3.2i
)

thm (minex2() () (-> (e. A S) (<= (min S) A))
  A S minex  
  ## <d ''Remove Left Side of AND' '>
    (e. (min S) S) (<= (min S) A) pm3.27
    syl
  ## </d ''Remove Left Side of AND' '>
)

## <title> Substitution </title>
## <table>
##   (-> ph (->  [ ps ]   ]    ]  th))
##   (<->        [ ps ]   [ ch ] )
##   (-> ph (->  [    [   [ ch ]  th))
## </table>
thm (BiReplaceImp1Imp0 () (
     replacee (-> ph (-> ps th))
     substitution (<-> ps ch)) 
     (-> ph (-> ch th))
  replacee
  substitution
th imbi1i
ph imbi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (-> ph (=  [ A ]   ]   ]  C))
##   (=         [ A ]   [ B ] )
##   (-> ph (=  [   [   [ B ]  C))
## </table>
thm (EqReplaceImp1Eq0 () (
     replacee (-> ph (= A C))
     substitution (= A B)) 
     (-> ph (= B C))
  replacee substitution
  C eqeq1i
  sylib
)

## <title> Minimum of a Union </title>
thm (minun() () (-> (/\ (e. (min S) S) (<= (min S) (min T))) (= (min S) (min (u. S T))))
  (min S) S minex
  ## <d ''Remove Right Side of AND' '>
    (e. (min S) S) (<= (min S) (min S)) pm3.26
    syl
  ## </d ''Remove Right Side of AND' '>
  (min S) S T unc
  syl

  y S minex2
  (<= (min S) (min T)) a1i
  y T minex2
  (<= (min S) (min T)) a1i
  (min S) (min T) y letr    
  ## <d 'Import-Export Theorem '>
    (<= (min S) (min T)) (<= (min T) y) (<= (min S) y) impexp
    mpbi
  ## </d 'Import-Export Theorem '>
  syld
  jaod
  y S T elun bicomi  
  BiReplaceImp1Imp0
  y 19.21ai
  anim12i  
  ## <d>
    (min S) (u. S T) y minsetval
    syl
  ## </d>
  y (u. S T) removeab
  minseqi  
  EqReplaceImp1Eq1
)

## <title> Substitution </title>
## <table>
##   (-> (/\ (e.  [ A ]   ]   ]  S) ph) ps)
##   (=           [ A ]   [ B ] )
##   (-> (/\ (e.  [   [   [ B ]  S) ph) ps)
## </table>
thm (EqReplaceImp0An0El0 () (
     replacee (-> (/\ (e. A S) ph) ps)
     substitution (= A B)) 
     (-> (/\ (e. B S) ph) ps)
  replacee substitution
  S eleq1i
  BiReplaceImp0An0
)

## <title> Substitution </title>
## <table>
##   (-> (/\ ph (<=  [ A ]   ]   ]  C)) ps)
##   (=              [ A ]   [ B ] )
##   (-> (/\ ph (<=  [   [   [ B ]  C)) ps)
## </table>
thm (EqReplaceImp0An1Le0 () (
     replacee (-> (/\ ph (<= A C)) ps)
     substitution (= A B)) 
     (-> (/\ ph (<= B C)) ps)
  replacee substitution
  C leeq1i
  BiReplaceImp0An1
)

thm (minuni () (hyp1 (/\ (= A (min S)) (e. A S)) hyp2 (<= A (min T))) (/\ (= A (min (u. S T))) (e. A (u. S T)))
  hyp1  
  ## <d ''Remove Left Side of AND' '>
    (= A (min S)) (e. A S) pm3.27
    ax-mp
  ## </d ''Remove Left Side of AND' '>
  hyp2
  pm3.2i

  S T minun
  hyp1
  ## <d ''Remove Right Side of AND' '>
    (= A (min S)) (e. A S) pm3.26
    ax-mp
  ## </d ''Remove Right Side of AND' '>
  eqcomi
  
  EqReplaceImp0An0El0

  hyp1
  ## <d ''Remove Right Side of AND' '>
    (= A (min S)) (e. A S) pm3.26
    ax-mp
  ## </d ''Remove Right Side of AND' '>
  eqcomi  
  EqReplaceImp0An1Le0

  hyp1
  ## <d ''Remove Right Side of AND' '>
    (= A (min S)) (e. A S) pm3.26
    ax-mp
  ## </d ''Remove Right Side of AND' '>
  eqcomi  
  EqReplaceImp1Eq0
  ax-mp

  hyp1  
  ## <d ''Remove Left Side of AND' '>
    (= A (min S)) (e. A S) pm3.27
    ax-mp
  ## </d ''Remove Left Side of AND' '>
  A S T unc ax-mp
  pm3.2i
)

## <summary> Main theorem giving mod its value </summary>
thm (modval ((A y) (B y) (C y)) ()
  (-> (/\ (< C B) (E. y (= (+ (* B y) C) A))) (= C (mod A B)))

  (< C B) (E. y (= (+ (* B y) C) A)) pm3.27
    y y' B muleq2 C addeq1d A eqeq1d exalpha

    B y x A y' C modval.3
      B x addge01t B (+ B x) C letr mpan
    syl6
    con3d
    B C lecon C B df-ge bitri con2bii syl5ib
    C x lecon x C df-ge bitri syl6ibr
    ex y 19.23ai com12
    y' 19.23ai
    sylbi com3r
    imp x 19.21ai
  jca

    x z (* B y) addeq2 A eqeq1d y exbid rwffi
      x C (* B y) addeq2 A eqeq1d y exbid
    minval
  syl
  A B x y df-mod C eqeq2i sylibr
)

## <title> Modulo Value </title>
thm (modvali () (hyp (< C B)  hyp2 (= (+ (* B D) C) A)) (= (mod A B) C) 
  hyp
  y D tyex
  y D B muleq2 
  (* B y) (* B D) C addeq1  
  syl
  ImpReplaceEx1
  hyp2
  EqReplaceEx1Eq1
  pm3.2i
  C B y A modval  
  ax-mp
  
  ## <d>
    C (mod A B) eqcom
  ## </d>
  mpbi
)

# Identity law for modulo
thm (modid () ()
  (-> (< A B) (= (mod A B) A))
  x (0) tyex
    x (0) B muleq2 B mul0 syl6eq
    A addeq1d A addidr syl6eq
    x 19.22i
  ax-mp
  A B x A modval mpan2 eqcomd
)

## <context>
##   This theorem is part of a series of theorems that describe the properties
##   of whole number division. It is assumed that every number in this theorem
##   is a natural number. Whole number division gives the result of normal division
##   without the remainder.
## </context>

# Definition of division using set minimum instead of iota
thm (df-div-just ((A x y) (B x y)) ()
  (= (min ({|} x (= (+ (* B x) (mod A B)) A)))
    (min ({|} y (= (+ (* B y) (mod A B)) A))))
  x y B muleq2 (mod A B) addeq1d A eqeq1d abeq
  ({|} x (= (+ (* B x) (mod A B)) A)) ({|} y (= (+ (* B y) (mod A B)) A)) minseq ax-mp
)

defthm (df-div nat (div A B) ((A x) (B x)) ()
  (= (div A B) (min ({|} x (= (+ (* B x) (mod A B)) A))))
  y B A x df-div-just
)

## <title> Equivalence for div </title> ##
thm (diveq1 () () (-> (= A C) (= (div A B) (div C B)))
  A C B modeq1
  (* B x) addeq2d
  (= A C) id
  eqeq12d
  x abbi2d
  minseqd
  A B x df-div eqcomi  
  EqReplaceImp1Eq0
  C B x df-div eqcomi  
  EqReplaceImp1Eq1
)

thm (diveq2 () () (-> (= B C) (= (div A B) (div A C)))
  B C x muleq1
  B C A modeq2
  addeq12d
  A eqeq1d
  x abbi2d
  minseqd
  A B x df-div eqcomi  
  EqReplaceImp1Eq0
  A C x df-div eqcomi  
  EqReplaceImp1Eq1
)

thm (diveq12 () () (-> (/\ (= A B) (= C D)) (= (div A C) (div B D)))
  A B C diveq1
  C D B diveq2
  anim12i
  ## <d 'Transitive Property '>
    (div A C) (div B C) (div B D) eqtr
    syl
  ## </d 'Transitive Property '>
)

## <title> Divide both sides of an equation </title>
## <table>
##   (=      [ A    ]       [ C  )
##   (= (div [ A B) ]  (div [ C B))
## </table>
thm (diveq1i () (
     hyp1 (= A C))
     (= (div A B) (div C B))
  hyp1
  A C B diveq1
  ax-mp
)

thm (diveq1d () (
     hyp1 (-> ph (= A C)))
     (-> ph (= (div A B) (div C B)))
  hyp1
  A C B diveq1
  syl
)

thm (diveq2i () (
     hyp1 (= A B))
     (= (div C A) (div C B))
  hyp1
  A B C diveq2
  ax-mp
)

thm (diveq2d () (
     hyp1 (-> ph (= A B)))
     (-> ph (= (div C A) (div C B)))
  hyp1
  A B C diveq2
  syl
)

## <context>
##   This theorem is part of a series of theorems that describe the properties
##   of set minumum, modulo, and whole number division. It is assumed that every number in this theorem
##   is a natural number.
## </context>

# number 108.0
thm (modex ((A y) (B y)) () (E. y (= (+ (* B y) (mod A B)) A))
    y  (0)  tyex
      y  (0)  B  muleq2
    B  mul0  syl6eq  A  addeq1d    A  addidr  syl6eq   y  19.22i    ax-mp
    x  A  (* B y)  addeq2  A  eqeq1d   y  exbid
    ({|} x  (E. y (= (+ (* B y) x) A)))  seqid     elab2
  biimpri  ax-mp
  A  ({|} x  (E. y (= (+ (* B y) x) A)))  minex  ax-mp
  pm3.26i
  A  B  x  y  df-mod    (mod A B)  (min ({|} x (E. y (= (+ (* B y) x) A))))  ({|} x (E. y (= (+ (* B y) x) A)))  ax-eleq1  ax-mp
mpbir

    x  (mod A B)  (* B y)  addeq2  A  eqeq1d   y  exbid
    ({|} x  (E. y (= (+ (* B y) x) A)))  seqid     elab2
mpbi
)

# number 107.0
thm (modle1 () () (<= (mod A B) A)
    y  (0)  tyex
      y  (0)  B  muleq2
    B  mul0  syl6eq  A  addeq1d    A  addidr  syl6eq   y  19.22i    ax-mp
    x  A  (* B y)  addeq2  A  eqeq1d   y  exbid
    ({|} x  (E. y (= (+ (* B y) x) A)))  seqid     elab2
  biimpri  ax-mp
  A  ({|} x  (E. y (= (+ (* B y) x) A)))  minex  ax-mp
  pm3.27i
      A  B  x  y  df-mod    A  leeq1i  mpbir
)

## <summary> Main theorem about division </summary>
thm (div () () (= (+ (* B (div A B)) (mod A B)) A)
   x B A modex
    x y B muleq2 (mod A B) addeq1d A eqeq1d rwffi
    A B x df-div x eqeq2i biimpri x (div A B) B muleq2 syl (mod A B) addeq1d A eqeq1d
    minel
  ax-mp
)

# number 109.0
thm (modmin ((A x) (B x) (C x)) () (-> (E. x (= (+ (* A x) B) C)) (<= (mod C A) B))

    y B (* A x) addeq2 C eqeq1d x exbid
    ({|} y (E. x (= (+ (* A x) y) C))) seqid elab2   biimpri
    B  ({|} y (E. x (= (+ (* A x) y) C)))  minex  syl  pm3.27d
          C  A  y  x  df-mod    B  leeq1i  biimpri  syl
)

## <title> Substitution </title>
## <table>
##   (= A (+ B  [ C ]   ]   ] ))
##   (=         [ C ]   [ D ] )
##   (= A (+ B  [   [   [ D ] ))
## </table>
thm (EqReplaceEq1Add1 () (
     replacee (= A (+ B C))
     substitution (= C D)) 
     (= A (+ B D))
  replacee substitution
  B addeq2i
  EqReplaceEq1
)


# number 110.0
thm (modlt2 () () (< (mod A (+ B (1))) (+ B (1)))
B  pa_axplus1
  (+ B (1))  (mod A (+ B (1))) x  df-le   biimpi
    y  (+ B (1))  A modex
      (+ (+ B (1)) x)  (mod A (+ B (1)))  (* (+ B (1)) y)  addeq2   A  eqeq1d  biimprd     y 19.22d
    mpi
  ## <d 'Distributive Property '>
    (+ B (1)) y (1) distr
    (+ B (1)) mulid
    EqReplaceEq1Add1
  ## </d 'Distributive Property '>
  x addeq1i  
  ## <d 'Associative Property '>
    (* (+ B (1)) y) (+ B (1)) x addass
    EqReplaceEq1
  ## </d 'Associative Property '>
      A  eqeq1i  biimpri
        (= (+ (* (+ B (1)) (+ y (1))) x) A)  z  alnfi
          z  (+ y (1))  tyex
          z  (+ y (1))  (+ B (1))  muleq2  x  addeq1d    A  eqeq1d    biimprd   z  19.22i    ax-mp
          z  (= (+ (* (+ B (1)) (+ y (1))) x) A)  (= (+ (* (+ B (1)) z) x) A)  eximp1    ax-mp
        syl
      syl
      z  (+ B (1))  x  A  modmin    syl
    y  19.22i  syl     y  (<= (mod A (+ B (1))) x)  ex-nf    syl
      x  (+ B (1))  addge02t      (= (+ (+ B (1)) x) (mod A (+ B (1))))  id    x  leeq2d   biimpd  mpi
    jca
    (mod A (+ B (1)))  x  lesym    biimpri  syl   eqcoms  ancli    eqcoms
    (mod A (+ B (1)))  (+ (+ B (1)) x)  x  eqtr2    syl
    x  addidr  syl6eqr
    (+ B (1))  x  (0)  addcan    sylib  eqcomd
  x  19.22i    syl  x  (= (0) (+ B (1)))  ex-nf  syl
  con3i
ax-mp
  ## <d 'Def. Greater Than '>
    (+ B (1)) (mod A (+ B (1))) df-gt bicomi
    mpbi
  ## </d 'Def. Greater Than '>
  ## <d 'Converse of < '>
    (mod A (+ B (1))) (+ B (1)) ltcon bicomi
    mpbi
  ## </d 'Converse of < '>
)

## <title> Divides and modulo equivalence </title>
## <summary> Divides relation is equivalent to zero remainder </summary>
thm (dividesmod () () (<-> (| A B) (= (mod B A) (0)))
  A  B  x  df-divides
    (* A x)  addid  B  eqeq1i  x  exbii  bitr4i
  x  A  (0)  B  modmin  sylbi     (mod B A)  eq0le0      sylibr

    x  A  B   modex
    (mod B A)  (0)  (* A x)  addeq2  B  eqeq1d   (* A x)  addid  B  eqeq1i   syl6bb  x exbid    mpbii
    A  B  x  df-divides  sylibr

    impbii
)

## <title> Substitution </title>
## <table>
##   (-> (-.  [ ph ]   ]    ] ) ch)
##   (<->     [ ph ]   [ ps ] )
##   (-> (-.  [    [   [ ps ] ) ch)
## </table>
thm (BiReplaceImp0Not0 () (
     replacee (-> (-. ph) ch)
     substitution (<-> ph ps)) 
     (-> (-. ps) ch)
  replacee substitution
  con4biir
  sylbi2
)

thm (muldiv () ()
  (-> (< (0) B) (= (div (* B A) B) A))

  (* B (div (* B A) B)) addid
    B dividessym B B A dividesmul ax-mp
    B (* B A) dividesmod mpbi
    (* B (div (* B A) B)) addeq2i
    B (* B A) div eqtr3
  eqtr3
  B (div (* B A) B) A mulcan2 mpbii
  ## <d>
    B eq0le0  
    BiReplaceImp0Not0
    B (0) df-gt bicomi  
    sylbi2
    ## <d 'Converse of < '>
      (0) B ltcon bicomi
      sylbi2
    ## </d 'Converse of < '>
  ## </d>
)

## <title> Cancel multiplication for numbers above 0 </title>
## <table>
##   (> <r> A (0))
##   (= (div (* <r> A B) <r> A) B)
## </table>
thm (muldivi () (hyp (> A (0))) (= (div (* A B) A) B)
  hyp  
  ## <d 'Converse of < '>
    (0) A ltcon bicomi
    mpbi
  ## </d 'Converse of < '>
  A B muldiv  
  ax-mp
)



## <context>
##   This theorem is part of a series of theorems that describe the properties
##   of even and odd numbers.
## </context>

## <title> Even Number Definition </title>
## <summary>
##   An even number is divisible by 2.
## </summary>
## <suggest> right('Define', 'Ev') left('Simplify', 'Ev') </suggest>
defthm  (df-even wff (even A) () () (<-> (even A) (| (2) A))
  (| (2) A) biid
)



thm (eveneq () () (-> (= A B) (<-> (even A) (even B)))
  A B (2) divideseq2  
  ## <d 'Even Number Definition '>
    A df-even bicomi
    BiReplaceImp1Bi0
  ## </d 'Even Number Definition '>  
  ## <d 'Even Number Definition '>
    B df-even bicomi
    BiReplaceImp1Bi1
  ## </d 'Even Number Definition '>
)

thm (eveneqi () (
     hyp1 (= A B))
     (<-> (even A) (even B))
  hyp1
  A B eveneq
  ax-mp
)

thm (eveneqd () (
     hyp1 (-> ph (= A B)))
     (-> ph (<-> (even A) (even B)))
  hyp1
  A B eveneq
  syl
)

## <title> Odd Number Definition </title>
## <summary>
##   An odd number is not divisible by 2.
## </summary>
## <suggest> right('Define', 'Odd') left('Simplify', 'Odd') </suggest>
defthm  (df-odd wff (odd A) () () (<-> (odd A) (-. (| (2) A)))
  (-. (| (2) A)) biid
)

## <title> An Odd Number is Not Even </title>
thm (oddNotEven () () (<-> (-. (even A)) (odd A))
  A df-even  
  ## <d 'Negate Both Sides '>
    (even A) (| (2) A) notbi
    mpbi
  ## </d 'Negate Both Sides '>
  ## <d 'Odd Number Definition '>
    A df-odd bicomi
    bitri
  ## </d 'Odd Number Definition '>
)

## <title> An Odd Number is Not Even </title>
thm (evenNotOdd () () (<-> (-. (odd A)) (even A))
  A df-odd  
  ## <d 'Negate Both Sides '>
    (odd A) (-. (| (2) A)) notbi
    mpbi
    (| (2) A) notnotr
    bitri
  ## </d 'Negate Both Sides '>  
  ## <d 'Even Number Definition '>
    A df-even bicomi
    bitri
  ## </d 'Even Number Definition '>
)



## <context>
##   This theorem is part of a series of theorems that describe the properties
##   of set minumum, modulo, and whole number division. It is assumed that every number in this theorem
##   is a natural number.
## </context>

## <title> All nonzero natural numbers are positive </title>
## <suggest> right('Equivalence', '<') </suggest>
thm (0inequalities () () (<-> (-. (= (0) A)) (< (0) A))
  A 0le    
  ## <d '≤ means < OR = '>
    (0) A leleo
    mpbi
  ## </d '≤ means < OR = '>      
  ## <d 'Definition of OR '>
    (< (0) A) (= (0) A) df-or
    mpbi     
  ## </d 'Definition of OR '>
  ## <d 'Negate Both Sides '>
    (-. (< (0) A)) (= (0) A) con34b
    mpbi
    (< (0) A) notnotr
    sylib
  ## </d 'Negate Both Sides '>          
  ## <d 'Operator Conversion '>
    (0) A ltneq
  ## </d 'Operator Conversion '>
  impbii
)


## <title> Substitution </title>
## <table>
##   (<-> (-.  [ ph ]   ]    ] ) ch)
##   (<->      [ ph ]   [ ps ] )
##   (<-> (-.  [    [   [ ps ] ) ch)
## </table>
thm (BiReplaceBi0Not0 () (
     replacee (<-> (-. ph) ch)
     substitution (<-> ph ps)) 
     (<-> (-. ps) ch)
  replacee substitution
  con4biir
  bitr3icom
)


## <title> All nonzero natural numbers are positive </title>
## <suggest> right('Equivalence', '<') </suggest>
thm (0inequalities2 () () (<-> (-. (= A (0))) (> A (0)))
  A 0inequalities
  ## <d 'Symmetric Property '>
    (0) A eqcom
    BiReplaceBi0Not0
  ## </d 'Symmetric Property '>
  ## <d 'Commute Inequality '>
    (0) A ltcon
    bitri
  ## </d 'Commute Inequality '>
)

## <title> Substitution </title>
## <table>
##   (<-> ph (<=  [ A ]   ]   ]  C))
##   (=           [ A ]   [ B ] )
##   (<-> ph (<=  [   [   [ B ]  C))
## </table>
thm (EqReplaceBi1Le0 () (
     replacee (<-> ph (<= A C))
     substitution (= A B)) 
     (<-> ph (<= B C))
  replacee
  substitution
C leeq1i
ph bibi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> ph (<  [ A ]   ]   ]  C))
##   (=          [ A ]   [ B ] )
##   (<-> ph (<  [   [   [ B ]  C))
## </table>
thm (EqReplaceBi1Lt0 () (
     replacee (<-> ph (< A C))
     substitution (= A B)) 
     (<-> ph (< B C))
  replacee substitution
  C lteq1i
  bitri
)

## <title> Substitution </title>
## <table>
##   (<-> ph (< A  [ B ]   ]   ] ))
##   (=            [ B ]   [ C ] )
##   (<-> ph (< A  [   [   [ C ] ))
## </table>
thm (EqReplaceBi1Lt1 () (
     replacee (<-> ph (< A B))
     substitution (= B C)) 
     (<-> ph (< A C))
  replacee substitution
  A lteq2i
  bitri
)

## <title> Substitution </title>
## <table>
##   (-> ph (| A  [ B ]   ]   ] ))
##   (=           [ B ]   [ C ] )
##   (-> ph (| A  [   [   [ C ] ))
## </table>
thm (EqReplaceImp1Divs1 () (
     replacee (-> ph (| A B))
     substitution (= B C)) 
     (-> ph (| A C))
  replacee substitution
  A divideseq2i
  sylib
)



## <title> Substitution </title>
## <table>
##   (<-> ph (<= (+ A  [ B ]   ]   ] ) D))
##   (=                [ B ]   [ C ] )
##   (<-> ph (<= (+ A  [   [   [ C ] ) D))
## </table>
thm (EqReplaceBi1Le0Add1 () (
     replacee (<-> ph (<= (+ A B) D))
     substitution (= B C)) 
     (<-> ph (<= (+ A C) D))
  replacee substitution
  A addeq2i
  EqReplaceBi1Le0
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x  [ ps ]   ]    ] ))
##   (<->          [ ps ]   [ ch ] )
##   (-> ph (E. x  [    [   [ ch ] ))
## </table>
thm (BiReplaceImp1Ex1 () (
     replacee (-> ph (E. x ps))
     substitution (<-> ps ch)) 
     (-> ph (E. x ch))
  replacee substitution
  x exbii
  sylib
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\  [ ps ]   ]    ]  th)))
##   (<->              [ ps ]   [ ch ] )
##   (-> ph (E. x (/\  [    [   [ ch ]  th)))
## </table>
thm (BiReplaceImp1Ex1An0 () (
     replacee (-> ph (E. x (/\ ps th)))
     substitution (<-> ps ch)) 
     (-> ph (E. x (/\ ch th)))
  replacee substitution
  th anbi1i
  BiReplaceImp1Ex1
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (/\ (<=  [ A ]   ]   ]  C) ps)))
##   (=                    [ A ]   [ B ] )
##   (-> ph (E. x (/\ (<=  [   [   [ B ]  C) ps)))
## </table>
thm (EqReplaceImp1Ex1An0Le0 () (
     replacee (-> ph (E. x (/\ (<= A C) ps)))
     substitution (= A B)) 
     (-> ph (E. x (/\ (<= B C) ps)))
  replacee substitution
  C leeq1i
  BiReplaceImp1Ex1An0
)


## <title> Substitution </title>
## <table>
##   (E. x (-> ph  [ ps ]   ]    ] ))
##   (<->          [ ps ]   [ ch ] )
##   (E. x (-> ph  [    [   [ ch ] ))
## </table>
thm (BiReplaceEx1Imp1 () (
     replacee (E. x (-> ph ps))
     substitution (<-> ps ch)) 
     (E. x (-> ph ch))
  replacee substitution
  ph imbi2i
  exbiii
)

## <title> Substitution </title>
## <table>
##   (-> ph (/\  [ ps ]   ]    ]  th))
##   (->         [ ps ]   [ ch ] )
##   (-> ph (/\  [    [   [ ch ]  th))
## </table>
thm (ImpReplaceImp1An0 () (
     replacee (-> ph (/\ ps th))
     substitution (-> ps ch)) 
     (-> ph (/\ ch th))
  replacee substitution
  th anim1i
  syl
)

## <title> Substitution </title>
## <table>
##   (-> ph (<  [ A ]   ]   ]  C))
##   (=         [ A ]   [ B ] )
##   (-> ph (<  [   [   [ B ]  C))
## </table>
thm (EqReplaceImp1Lt0 () (
     replacee (-> ph (< A C))
     substitution (= A B)) 
     (-> ph (< B C))
  replacee substitution
  C lteq1i
  sylib
)


## <title> Substitution </title>
## <table>
##   (-> ph (< A  [ B ]   ]   ] ))
##   (=           [ B ]   [ C ] )
##   (-> ph (< A  [   [   [ C ] ))
## </table>
thm (EqReplaceImp1Lt1 () (
     replacee (-> ph (< A B))
     substitution (= B C)) 
     (-> ph (< A C))
  replacee substitution
  A lteq2i
  sylib
)

thm (modlt () () (-> (< (0) B) (< (mod A B) B))
  (1) B (1) halfminusaddcom
  ## <d>
    B (1) halfminuscan
    EqReplaceImp1Eq1
  ## </d>
  A modeq2d
  (1) B (1) halfminusaddcom
  ## <d>
    B (1) halfminuscan
    EqReplaceImp1Eq1
  ## </d>
  (mod A (+ (.- B (1)) (1))) lteq2d
  A (.- B (1)) modlt2
  (< (mod A (+ (.- B (1)) (1))) B) biRemove1
  (<= (1) B) imbi2i
  mpbi
  jca
  (mod A (+ (.- B (1)) (1))) (mod A B) B lteq1  
  ImpReplaceImp1An0
  ## <d 'Commutative Property '>
    (<-> (< (mod A (+ (.- B (1)) (1))) B) (< (mod A B) B)) (< (mod A (+ (.- B (1)) (1))) B) ancom
    sylib
  ## </d 'Commutative Property '>
  ## <d>
    (< (mod A (+ (.- B (1)) (1))) B) (< (mod A B) B) mpbi-inline
    syl
  ## </d>
  (0) B ltle2
  ## <d 'Additive Identity Axiom '>
    (1) addidr
    EqReplaceBi1Le0
  ## </d 'Additive Identity Axiom '>

  ## <d 'Commutative Property '>
    (< (0) B) (<= (1) B) bicom
    mpbi
  ## </d 'Commutative Property '>

  sylbi2
)

## <title> A non-multiple occurs between two multiples </title>
thm (notDivides2 ((B x) (A x)) () (-> (/\ (-. (| A B)) (> A (0))) (E. x (/\ (< (* A x) B) (< B (* A (+ x (1)))))))
  x (div B A) tyex
  (div B A) x A muleq2
  B lteq1d
  (div B A) x (1) addeq1
  A muleq2d
  B lteq2d
  anbi12d
  (/\ (-. (| A B)) (< (0) A)) imbi2d


  A B dividesmod
  ## <d 'Negate Both Sides '>
    (| A B) (= (mod B A) (0)) notbi
    mpbi
  ## </d 'Negate Both Sides '>

  ## <d 'All nonzero natural numbers are positive '>
    (mod B A) 0inequalities2
    bitri
  ## </d 'All nonzero natural numbers are positive '>
  
  ## <d 'Converse of < '>
    (0) (mod B A) ltcon bicomi
    bitri
  ## </d 'Converse of < '>


 (0) (mod B A) (* A (div B A))  ltadd2

  ## <d 'Additive Identity Axiom '>
    (* A (div B A)) addid
    EqReplaceBi1Lt0
  ## </d 'Additive Identity Axiom '>

  bitri
  A B div
  EqReplaceBi1Lt1
  ## <d 'Infer Left to Right '>
    (-. (| A B)) (< (* A (div B A)) B) bi1
    ax-mp
  ## </d 'Infer Left to Right '>

  A B modlt
 (mod B A) A (* A (div B A))  ltadd2
  sylib

  A B div
  EqReplaceImp1Lt0
  A mulid
  (* A (div B A)) addeq2i eqcomi
  ## <d 'Distributive Property '>
    A (div B A) (1) distr
    ## <d 'Commutative Property'>
      (* A (+ (div B A) (1))) (+ (* A (div B A)) (* A (1))) eqcom
      mpbi
    ## </d 'Commutative Property'>
    EqReplaceEq1
  ## </d 'Distributive Property '>

        EqReplaceImp1Lt1
  pm3.2i
  ## <d 'Praeclarum Theorema '>
    (-. (| A B)) (< (* A (div B A)) B) (< (0) A) (< B (* A (+ (div B A) (1)))) prth
    ax-mp
  ## </d 'Praeclarum Theorema '>

  (-> (/\ (-. (| A B)) (< (0) A)) (/\ (< (* A x) B) (< B (* A (+ x (1)))))) biRemove1
  (= (div B A) x) imbi2i
  mpbi

  ## <d 'Symmetric Property '>
    (div B A) x eqcom
    sylbi2
  ## </d 'Symmetric Property '>

  ImpReplaceEx1

  (/\ (-. (| A B)) (< (0) A)) x (/\ (< (* A x) B) (< B (* A (+ x (1)))))
  imex bicomi
  mpbi

  ## <d 'Commute Inequality '>
    (0) A ltcon
    BiReplaceImp0An1
  ## </d 'Commute Inequality '>
)

## <title> A non-multiple occurs between two multiples </title>
thm (notDivides3 ((B x)(A x)) () (-> (> A (0)) (<-> (-. (| A B)) (E. x (/\ (< (* A x) B) (< B (* A (+ x (1))))))))
  A B x notDivides2  
  ## <d 'Commute Conjunction '>
    (-. (| A B)) (> A (0)) ancom
    sylbi2
  ## </d 'Commute Conjunction '>  
  ## <d 'Import-Export Theorem '>
    (> A (0)) (-. (| A B)) (E. x (/\ (< (* A x) B) (< B (* A (+ x (1)))))) impexp
    mpbi
  ## </d 'Import-Export Theorem '>
  A x B notDivides
  x 19.22i  
  ## <d 'Quantified Non-free Variable '>
    x (-. (| A B)) 19.9
    sylib
  ## </d 'Quantified Non-free Variable '>
  (> A (0)) a1i
  impbid
)

## <title> Substitution </title>
## <table>
##   (<-> ph (E. x  [ ps ]   ]    ] ))
##   (<->           [ ps ]   [ ch ] )
##   (<-> ph (E. x  [    [   [ ch ] ))
## </table>
thm (BiReplaceBi1Ex1 () (
     replacee (<-> ph (E. x ps))
     substitution (<-> ps ch)) 
     (<-> ph (E. x ch))
  replacee substitution
  x exbii
  bitri
)

## <title> Substitution </title>
## <table>
##   (<-> ph (E. x (/\ ps  [ ch ]   ]    ] )))
##   (<->                  [ ch ]   [ th ] )
##   (<-> ph (E. x (/\ ps  [    [   [ th ] )))
## </table>
thm (BiReplaceBi1Ex1An1 () (
     replacee (<-> ph (E. x (/\ ps ch)))
     substitution (<-> ch th)) 
     (<-> ph (E. x (/\ ps th)))
  replacee substitution
  ps anbi2i
  BiReplaceBi1Ex1
)

## <title> Substitution </title>
## <table>
##   (<-> ph (E. x (/\ ps (< A  [ B ]   ]   ] ))))
##   (=                         [ B ]   [ C ] )
##   (<-> ph (E. x (/\ ps (< A  [   [   [ C ] ))))
## </table>
thm (EqReplaceBi1Ex1An1Lt1 () (
     replacee (<-> ph (E. x (/\ ps (< A B))))
     substitution (= B C)) 
     (<-> ph (E. x (/\ ps (< A C))))
  replacee substitution
  A lteq2i
  BiReplaceBi1Ex1An1
)

## <title> Substitution </title>
## <table>
##   (<-> ph (E. x (/\  [ ps ]   ]    ]  th)))
##   (<->               [ ps ]   [ ch ] )
##   (<-> ph (E. x (/\  [    [   [ ch ]  th)))
## </table>
thm (BiReplaceBi1Ex1An0 () (
     replacee (<-> ph (E. x (/\ ps th)))
     substitution (<-> ps ch)) 
     (<-> ph (E. x (/\ ch th)))
  replacee substitution
  th anbi1i
  BiReplaceBi1Ex1
)

## <title> Substitution </title>
## <table>
##   (> A  [ B ]   ]   ] )
##   (>    [ B ]   [ C ] )
##   (> A  [   [   [ C ] )
## </table>
thm (GtReplaceGt1 () (
     replacee (> A B)
     substitution (> B C)) 
     (> A C)
  replacee substitution
  A gtTrgt
  ax-mp
)


## <title> One-Digit Inequality </title>
thm (2greater0 () () (> (2) (0))
  ## <d 'Separate into smaller inequalities'>
    2greater1
    1greater0
    GtReplaceGt1
  ## </d 'Separate into smaller inequalities'>
)

## <title> Substitution </title>
## <table>
##   (<-> ph (<= A  [ B ]   ]   ] ))
##   (=             [ B ]   [ C ] )
##   (<-> ph (<= A  [   [   [ C ] ))
## </table>
thm (EqReplaceBi1Le1 () (
     replacee (<-> ph (<= A B))
     substitution (= B C)) 
     (<-> ph (<= A C))
  replacee
  substitution
A leeq2i
ph bibi2i
mpbi
)

## <context>
##   This theorem is part of a series of theorems that describe the properties
##   of even and odd numbers. It is assumed that every number in this theorem
##   is a natural number.
## </context>

## <title> Alternative Odd Number Definition </title>
thm (oddex ((A x)) () (<-> (odd A) (E. x (= (+ (* (2) x) (1)) A)))
  ## <d 'Formula for 2 does not divide A'>
  (2) A x notDivides3
  ## <d '2 > 0'>
    2greater0
    ax-mpRemove
  ## </d '2 > 0'>  
  ## </d>  
  ## <d 'Distributive Property '>
    (2) x (1) distr
    (2) mulid
    EqReplaceEq1Add1
    EqReplaceBi1Ex1An1Lt1
  ## </d 'Distributive Property '>   
  ## <d 'Convert between ≤ and < '> 
  ## <d 'Convert between ≤ and < '>
    (* (2) x) A ltle2  
    BiReplaceBi1Ex1An0
  ## </d 'Convert between ≤ and < '>
  ## <d 'Convert between ≤ and < '>
  A (+ (* (2) x) (2)) ltle2
  1plus1 eqcomi
  (* (2) x) addeq2i
  (+ A (1)) leeq2i  
  bitri
  ## <d 'Associative Property '>
    (* (2) x) (1) (1) addass eqcomi
    EqReplaceBi1Le1
  ## </d 'Associative Property '>  
  ## <d 'Addition is Monotonic '>
    A (+ (* (2) x) (1)) (1) leadd1 bicomi
    bitri
  ## </d 'Addition is Monotonic '> 
  BiReplaceBi1Ex1An1
  ## </d 'Convert between ≤ and < '>   
  ## </d 'Convert between ≤ and < '>   
  ## <d 'Same upper and lower bound implies equality '>
    (+ (* (2) x) (1)) A lesym bicomi
    BiReplaceBi1Ex1
  ## </d 'Same upper and lower bound implies equality '>  
  ## <d 'Odd Number Definition '>
    A df-odd bicomi
    bitr3icom
  ## </d 'Odd Number Definition '>
)

## <title> Odd Numbers Are Above Even Numbers </title>
thm (evensuccessor () () (<-> (even A) (odd (+ A (1))))
  ## <d 'Even Number Definition '>
    A df-even
  ## </d 'Even Number Definition '>
  ## <d 'Divides Definition '>
    (2) A x df-divides
    bitri
  ## </d 'Divides Definition '>
  ## <d 'Add 1 to both sides '>
    (* (2) x) (1) A addcan bicomi  
    BiReplaceBi1Ex1
  ## </d 'Add 1 to both sides '>
  ## <d 'Alternative Odd Number Definition'>
  (+ A (1)) x oddex bicomi  
  bitri
  ## </d 'Alternative Odd Number Definition'>
)

## <title> Substitution </title>
## <table>
##   (<-> ph (E. x (=  [ A ]   ]   ]  C)))
##   (=                [ A ]   [ B ] )
##   (<-> ph (E. x (=  [   [   [ B ]  C)))
## </table>
thm (EqReplaceBi1Ex1Eq0 () (
     replacee (<-> ph (E. x (= A C)))
     substitution (= A B)) 
     (<-> ph (E. x (= B C)))
  replacee
  substitution
C eqeq1i
x exbii
ph bibi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (<-> ph (E. x (= (+ A  [ B ]   ]   ] ) D)))
##   (=                     [ B ]   [ C ] )
##   (<-> ph (E. x (= (+ A  [   [   [ C ] ) D)))
## </table>
thm (EqReplaceBi1Ex1Eq0Add1 () (
     replacee (<-> ph (E. x (= (+ A B) D)))
     substitution (= B C)) 
     (<-> ph (E. x (= (+ A C) D)))
  replacee substitution
  A addeq2i
  EqReplaceBi1Ex1Eq0
)

## <title> Even Numbers Are Above Odd Numbers </title>
thm (oddsuccessor () () (<-> (odd A) (even (+ A (1))))
  A evensuccessor  
  ## <d 'Negate Both Sides '>
    (even A) (odd (+ A (1))) notbi
    mpbi
  ## </d 'Negate Both Sides '>
  A oddNotEven  
  bitr3icom
  (+ A (1)) evenNotOdd  
  bitri
)

## <title> One of two consecutive numbers is even </title>
## <summary>
##   For two consecutive numbers, one of the numbers is even.
##   <a href="consecutiveOdd">consecutiveOdd</a> shows that one
##   of them is odd.
## </summary>
thm (consecutiveEven () () (\/ (even A) (even (+ A (1))))
  ## <d 'Even Numbers are Not Odd '>
    A evenNotOdd
    ## <d 'Infer Left to Right '>
      (-. (odd A)) (even A) bi1
      ax-mp
    ## </d 'Infer Left to Right '>
  ## </d>
  ## <d 'Even numbers are above odd numbers'>
    A oddsuccessor
    ## <d 'Infer Left to Right '>
      (odd A) (even (+ A (1))) bi1
      ax-mp
    ## </d 'Infer Left to Right '>
  ## </d 'Even numbers are above odd numbers'>
  orim12i
  ## <d 'Law of Excluded Middle'>
    (odd A) exmid
    ## <d 'Commutative Property of OR '>
      (odd A) (-. (odd A)) orcom
      mpbi
    ## </d 'Commutative Property of OR '>
  ## </d 'Law of Excluded Middle>
  ax-mpRemove
)


## <title> One of two consecutive numbers is odd </title>
## <summary>
##   For two consecutive numbers, one of the numbers is odd.
##   <a href="consecutiveEven">consecutiveEven</a> shows that one
##   of them is even.
## </summary>
thm (consecutiveOdd () () (\/ (odd A) (odd (+ A (1))))
  A evensuccessor  
  ## <d 'Infer Left to Right '>
    (even A) (odd (+ A (1))) bi1
    ax-mp
  ## </d 'Infer Left to Right '>
  ## <d 'Odd Numbers are Not Even '>
  A oddNotEven  
  ## <d 'Infer Left to Right '>
    (-. (even A)) (odd A) bi1
    ax-mp
  ## </d 'Infer Left to Right '>
  ## </d>
  orim12i  
  ## <d 'Law of Excluded Middle'>
    (even A) exmid    
    ax-mpRemove
  ## </d 'Law of Excluded Middle>  
  ## <d 'Commutative Property of OR '>
    (odd (+ A (1))) (odd A) orcom
    mpbi
  ## </d 'Commutative Property of OR '>
)

## <title> Any multiple of an even number is even </title>
thm (evenmul () () (-> (even A) (even (* A B)))
  (2) A B dividesmul  
  ## <d 'Even Number Definition '>
    A df-even bicomi
    sylbi2
  ## </d 'Even Number Definition '>
  ## <d 'Even Number Definition '>
    (* A B) df-even bicomi
    sylib
  ## </d 'Even Number Definition '>
)



## <title> Substitution </title>
## <table>
##   (= A (+  [ B ]   ]   ]  D))
##   (=       [ B ]   [ C ] )
##   (= A (+  [   [   [ C ]  D))
## </table>
thm (EqReplaceEq1Add0 () (
     replacee (= A (+ B D))
     substitution (= B C)) 
     (= A (+ C D))
  replacee substitution
  D addeq1i
  EqReplaceEq1
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x  [ ps ]   ]    ] ))
##   (->           [ ps ]   [ ch ] )
##   (-> ph (E. x  [    [   [ ch ] ))
## </table>
thm (ImpReplaceImp1Ex1 () (
     replacee (-> ph (E. x ps))
     substitution (-> ps ch)) 
     (-> ph (E. x ch))
  replacee substitution
  x 19.22i
  syl
)

## <title> Substitution </title>
## <table>
##   (= A (+ B (+ C  [ D ]   ]    ] )))
##   (=              [ D ]   [ A' ] )
##   (= A (+ B (+ C  [   [   [ A' ] )))
## </table>
thm (EqReplaceEq1Add1Add1 () (
     replacee (= A (+ B (+ C D)))
     substitution (= D A')) 
     (= A (+ B (+ C A')))
  replacee substitution
  C addeq2i
  EqReplaceEq1Add1
)

## <title> Substitution </title>
## <table>
##   (<-> ph  [ ps ]   ]    ] )
##   (->      [ ps ]   [ ch ] )
##   (<-> ph  [    [   [ ch ] )
## </table>
thm (ImpReplaceBi1 () (
     replacee (<-> ph ps)
     substitution (-> ps ch)) 
     (-> ph ch)
  replacee
  substitution
  ph biim2i
  ax-mp
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (E. y  [ ps ]   ]    ] )))
##   (->                 [ ps ]   [ ch ] )
##   (-> ph (E. x (E. y  [    [   [ ch ] )))
## </table>
thm (ImpReplaceImp1Ex1Ex1 () (
     replacee (-> ph (E. x (E. y ps)))
     substitution (-> ps ch)) 
     (-> ph (E. x (E. y ch)))
  replacee substitution
  y 19.22i
  ImpReplaceImp1Ex1
)


## <title> Substitution </title>
## <table>
##   (= A (+ (+ B  [ C ]   ]   ] ) A'))
##   (=            [ C ]   [ D ] )
##   (= A (+ (+ B  [   [   [ D ] ) A'))
## </table>
thm (EqReplaceEq1Add0Add1 () (
     replacee (= A (+ (+ B C) A'))
     substitution (= C D)) 
     (= A (+ (+ B D) A'))
  replacee substitution
  B addeq2i
  EqReplaceEq1Add0
)

## <title> Substitution </title>
## <table>
##   (= A (+ B (+  [ C ]   ]   ]  A')))
##   (=            [ C ]   [ D ] )
##   (= A (+ B (+  [   [   [ D ]  A')))
## </table>
thm (EqReplaceEq1Add1Add0 () (
     replacee (= A (+ B (+ C A')))
     substitution (= C D)) 
     (= A (+ B (+ D A')))
  replacee substitution
  A' addeq1i
  EqReplaceEq1Add1
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (E. y  [ ps ]   ]    ] )))
##   (<->                [ ps ]   [ ch ] )
##   (-> ph (E. x (E. y  [    [   [ ch ] )))
## </table>
thm (BiReplaceImp1Ex1Ex1 () (
     replacee (-> ph (E. x (E. y ps)))
     substitution (<-> ps ch)) 
     (-> ph (E. x (E. y ch)))
  replacee substitution
  y exbii
  BiReplaceImp1Ex1
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (E. y (=  [ A ]   ]   ]  C))))
##   (=                     [ A ]   [ B ] )
##   (-> ph (E. x (E. y (=  [   [   [ B ]  C))))
## </table>
thm (EqReplaceImp1Ex1Ex1Eq0 () (
     replacee (-> ph (E. x (E. y (= A C))))
     substitution (= A B)) 
     (-> ph (E. x (E. y (= B C))))
  replacee substitution
  C eqeq1i
  BiReplaceImp1Ex1Ex1
)

## <title> Substitution </title>
## <table>
##   (= A (+ (+  [ B ]   ]   ]  D) A'))
##   (=          [ B ]   [ C ] )
##   (= A (+ (+  [   [   [ C ]  D) A'))
## </table>
thm (EqReplaceEq1Add0Add0 () (
     replacee (= A (+ (+ B D) A'))
     substitution (= B C)) 
     (= A (+ (+ C D) A'))
  replacee substitution
  D addeq1i
  EqReplaceEq1Add0
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (E. y (E. z  [ ps ]   ]    ] ))))
##   (->                       [ ps ]   [ ch ] )
##   (-> ph (E. x (E. y (E. z  [    [   [ ch ] ))))
## </table>
thm (ImpReplaceImp1Ex1Ex1Ex1 () (
     replacee (-> ph (E. x (E. y (E. z ps))))
     substitution (-> ps ch)) 
     (-> ph (E. x (E. y (E. z ch))))
  replacee substitution
  z 19.22i
  ImpReplaceImp1Ex1Ex1
)

## <title> The product of odd numbers is odd </title>
thm (oddmul () () (-> (/\ (odd A) (odd B)) (odd (* A B)))
  A x oddex
  B y oddex
  anbi12i
  ## <d 'Combine Existence Quantifiers '>
    x (= (+ (* (2) x) (1)) A) y (= (+ (* (2) y) (1)) B) doubleex
    ImpReplaceBi1
  ## </d 'Combine Existence Quantifiers '>
  (+ (* (2) x) (1)) A (+ (* (2) y) (1)) B muleq12    
  ImpReplaceImp1Ex1Ex1

  ## <d 'Distributive Property '>
    ## <d 'Distributive Property '>
      (* (2) x) (1) (* (2) y) (1) distrl
      (* (2) y) mulidr
      EqReplaceEq1Add0Add1
      (* (2) x) mulid
      EqReplaceEq1Add1Add0
      (1) mulid
      EqReplaceEq1Add1Add1
      EqReplaceImp1Ex1Ex1Eq0
    ## </d 'Distributive Property '>
    ## <d 'Associative Property '>
      (+ (* (* (2) x) (* (2) y)) (* (2) y)) (* (2) x) (1) addass eqcomi
    ## </d 'Associative Property '>    
    ## <d 'Distributive Property '>
      (2) (+ (* x (* (2) y)) y) x distr
    ## </d 'Distributive Property '>  
    ## <d 'Distributive Property '>
      (2) (* x (* (2) y)) y distr
      EqReplaceEq1Add0
    ## </d 'Distributive Property '>  
    ## <d 'Associative Property '>
      (2) x (* (2) y) mulass eqcomi
      EqReplaceEq1Add0Add0
    ## </d 'Associative Property '>
    eqcomi  
    EqReplaceEq1Add0
    EqReplaceImp1Ex1Ex1Eq0
  ## </d>
  ## <d 'Replace (x ∙ (2 ∙ y) + y + x) with z'>
  z (+ (+ (* x (* (2) y)) y) x) (2) muleq2
  (1) addeq1d
  (* A B) eqeq1d
  ceqsex  bicomi
  BiReplaceImp1Ex1Ex1
  ## <d ''Remove Left Side of AND' '>
    (= z (+ (+ (* x (* (2) y)) y) x)) (= (+ (* (2) z) (1)) (* A B)) pm3.27
    ImpReplaceImp1Ex1Ex1Ex1
  ## </d ''Remove Left Side of AND' '>  
  ## <d 'Quantified Non-free Variable '>
    y (E. z (= (+ (* (2) z) (1)) (* A B))) 19.9
    BiReplaceImp1Ex1
  ## </d 'Quantified Non-free Variable '>
  ## <d 'Quantified Non-free Variable '>
    x (E. z (= (+ (* (2) z) (1)) (* A B))) 19.9
    sylib
  ## </d 'Quantified Non-free Variable '>
  ## </d 'Replace (x ∙ (2 ∙ y) + y + x) with z'>
  ## <d 'Alternative Definition of Odd Number'>
  (* A B) z oddex bicomi  
  sylib
  ## </d 'Alternative Definition of Odd Number'>
)


## <title> Substitution </title>
## <table>
##   (-> ph (\/ ps  [ ch ]   ]    ] ))
##   (<->           [ ch ]   [ th ] )
##   (-> ph (\/ ps  [    [   [ th ] ))
## </table>
thm (BiReplaceImp1Or1 () (
     replacee (-> ph (\/ ps ch))
     substitution (<-> ch th)) 
     (-> ph (\/ ps th))
  replacee substitution
  ps orbi2i
  sylib
)

## <title> Substitution </title>
## <table>
##   (-> ph (even  [ A ]   ]   ] ))
##   (=            [ A ]   [ B ] )
##   (-> ph (even  [   [   [ B ] ))
## </table>
thm (EqReplaceImp1Even0 () (
     replacee (-> ph (even A))
     substitution (= A B)) 
     (-> ph (even B))
  replacee substitution
  eveneqi
  sylib
)

## <title> Substitution </title>
## <table>
##   (-> ph (\/  [ ps ]   ]    ]  th))
##   (<->        [ ps ]   [ ch ] )
##   (-> ph (\/  [    [   [ ch ]  th))
## </table>
thm (BiReplaceImp1Or0 () (
     replacee (-> ph (\/ ps th))
     substitution (<-> ps ch)) 
     (-> ph (\/ ch th))
  replacee
  substitution
th orbi1i
ph imbi2i
mpbi
)

## <title> Multiplication of Even Numbers </title>
thm (evenmul2 () () (<-> (even (* A B)) (\/ (even A) (even B)))
  ## <d 'An even product has an even factor'>
  A B oddmul  
  ## <d 'Contrapositive '>
  ## <d 'Contrapositive '>
    (/\ (odd A) (odd B)) (odd (* A B)) con34b
    mpbi
  ## </d 'Contrapositive '>  
  ## <d 'DeMorgan's Law '>
  ## <d 'DeMorgan's Law '>
    (odd A) (odd B) anor
    BiReplaceImp1Not0
  ## </d 'DeMorgan's Law '>  
  ## <d 'Double Negative '>
    (\/ (-. (odd A)) (-. (odd B))) notnotr
    sylib
  ## </d 'Double Negative '>
  ## </d 'DeMorgan's Law '>  
  ## </d 'Contrapositive '> 
  ## <d 'Even Numbers are Not Odd'>
  (* A B) evenNotOdd  
  sylbi2
  A evenNotOdd    
  BiReplaceImp1Or0
  B evenNotOdd
  BiReplaceImp1Or1
  ## </d 'Even Numbers are Not Odd'>
  ## </d 'Q'>

  ## <d 'Even factors have even products'>
  A B evenmul
  B A evenmul  
  ## <d 'Commutative Property '>
    B A mulcom
    EqReplaceImp1Even0
  ## </d 'Commutative Property '>
  jaoi
  ## </d 'Even factors have even products'>
  impbii
)

## <title> Product of consecutive numbers is even </title>
thm (evenxxplus1 () () (even (* A (+ A (1))))
  # Intentionally copied consecutiveEven.
  ## <d 'One of two consecutive numbers is even'>
    ## <d 'One of two consecutive numbers is even'>
      ## <d 'Even Numbers are Not Odd '>
        A evenNotOdd
        ## <d 'Infer Left to Right '>
          (-. (odd A)) (even A) bi1
          ax-mp
        ## </d 'Infer Left to Right '>
      ## </d>
      ## <d 'Even numbers are above odd numbers'>
        A oddsuccessor
        ## <d 'Infer Left to Right '>
          (odd A) (even (+ A (1))) bi1
          ax-mp
        ## </d 'Infer Left to Right '>
      ## </d 'Even numbers are above odd numbers'>
      orim12i
      ## <d 'Law of Excluded Middle'>
        (odd A) exmid
        ## <d 'Commutative Property of OR '>
          (odd A) (-. (odd A)) orcom
          mpbi
        ## </d 'Commutative Property of OR '>
      ## </d 'Law of Excluded Middle>
      ax-mpRemove
    ## </d 'Consecutive Numbers: One is Even'>

    A (+ A (1)) evenmul
    ## <d>
      (+ A (1)) A evenmul  
      ## <d 'Commutative Property '>
        (+ A (1)) A mulcom
        EqReplaceImp1Even0
      ## </d 'Commutative Property '>
    ## </d>
    jaoi  
  ## </d>
  ax-mp
)

## <title> Product of consecutive numbers is even </title>
thm (div2xxplus1 () () (| (2) (* A (+ A (1))))
  A evenxxplus1  
  ## <d 'Even Number Definition '>
    (* A (+ A (1))) df-even
    mpbi
  ## </d 'Even Number Definition '>
)

## <context>
##   This theorem is part of a series of theorems that describe the properties
##   of modulo congruence. It is assumed that every number in this theorem
##   is a natural number.
## </context>

## <title> Modulo Congruence Definition </title>
## <summary>
##   Two numbers A and B are congruent modulo C if there values
##   mod C are equal.
## </summary>
defthm (df-modcon wff (=mod A B C) ()  ()  (<-> (=mod A B C) (= (mod A C) (mod B C)))
   (= (mod A C) (mod B C)) biid
)

thm (modconeq1 () () (-> (= A D) (<-> (=mod A B C) (=mod D B C)))
  A D C modeq1
  (mod B C) eqeq1d
  A B C df-modcon bicomi  
  BiReplaceImp1Bi0
  D B C df-modcon bicomi
  BiReplaceImp1Bi1
)

thm (modconeq2 () () (-> (= A D) (<-> (=mod B A C) (=mod B D C)))
  A D C modeq1
  (mod B C) eqeq2d
  B A C df-modcon bicomi
  BiReplaceImp1Bi0
  B D C df-modcon bicomi  
  BiReplaceImp1Bi1
)

thm (modconeq3 () () (-> (= A B) (<-> (=mod C D A) (=mod C D B)))
  A B C modeq2
  A B D modeq2
  eqeq12d
  C D A df-modcon bicomi  
  BiReplaceImp1Bi0
  C D B df-modcon bicomi    
  BiReplaceImp1Bi1
)

thm (modconeq1i () (
     hyp1 (= A D))
     (<-> (=mod A B C) (=mod D B C))
  hyp1
  A D B C modconeq1
  ax-mp
)

thm (modconeq1d () (
     hyp1 (-> ph (= A D)))
     (-> ph (<-> (=mod A B C) (=mod D B C)))
  hyp1
  A D B C modconeq1
  syl
)

thm (modconeq2i () (
     hyp1 (= A D))
     (<-> (=mod B A C) (=mod B D C))
  hyp1
  A D B C modconeq2
  ax-mp
)

thm (modconeq2d () (
     hyp1 (-> ph (= A D)))
     (-> ph (<-> (=mod B A C) (=mod B D C)))
  hyp1
  A D B C modconeq2
  syl
)

thm (modconeq3i () (
     hyp1 (= A B))
     (<-> (=mod C D A) (=mod C D B))
  hyp1
  A B C D modconeq3
  ax-mp
)

## <title> Equivalence for =mod </title> ##
thm (modconeq12 () () (-> (/\ (= A B) (= C D)) (<-> (=mod A C A') (=mod B D A')))
  A B C A' modconeq1
  C D B A' modconeq2
  anim12i
  ## <d 'Transitive Property'>
    (=mod A C A') (=mod B C A') (=mod B D A') bitr
    syl
  ## </d 'Transitive Property'>
)

thm (modconeq13 () () (-> (/\ (= A A') (= C C')) (<-> (=mod A B C) (=mod A' B C')))
  A A' B C modconeq1
  C C' A' B modconeq3
  anim12i  
  ## <d 'Transitive Property '>
    (=mod A B C) (=mod A' B C) (=mod A' B C') bitr
    syl
  ## </d 'Transitive Property '>
)

thm (modconeq23 () () (-> (/\ (= A A') (= C C')) (<-> (=mod B A C) (=mod B A' C')))
  A A' B C modconeq2
  C C' B A' modconeq3
  anim12i  
  ## <d 'Transitive Property '>
    (=mod B A C) (=mod B A' C) (=mod B A' C') bitr
    syl
  ## </d 'Transitive Property '>
)

thm (modconeq3d () (
     hyp1 (-> ph (= A B)))
     (-> ph (<-> (=mod C D A) (=mod C D B)))
  hyp1
  A B C D modconeq3
  syl
)

thm (modconeq12d () (
     hyp1 (-> ph (= A B))
     hyp2 (-> ph (= C D)))
     (-> ph (<-> (=mod A C A') (=mod B D A')))
  hyp1
  hyp2
  jca
  A B C D A' modconeq12
  syl
)

thm (modconeq13d () (
     hyp1 (-> ph (= A B))
     hyp2 (-> ph (= C D)))
     (-> ph (<-> (=mod A A' C) (=mod B A' D)))
  hyp1
  hyp2
  jca
  A B C D A' modconeq13
  syl
)

thm (modconeq23d () (
     hyp1 (-> ph (= A B))
     hyp2 (-> ph (= C D)))
     (-> ph (<-> (=mod A' A C) (=mod A' B D)))
  hyp1
  hyp2
  jca
  A B C D A' modconeq23
  syl
)


## <title> Reflexive Property </title>
thm (modconid () () (=mod A A C)
  (mod A C) eqid
  A A C df-modcon bicomi  
  mpbi
)

## <title> Symmetric Property </title>
## <suggest> right('Commute', '=') </suggest>
thm (modconcom () () (<-> (=mod A B C) (=mod B A C))
  (mod A C) (mod B C) eqcom
  A B C df-modcon bicomi  
  bitr3icom
  B A C df-modcon bicomi    
  bitri
)

## <title> Equality Implies Modular Congruence </title>
thm (eqmodcon () () (-> (= B C) (=mod B C A))
  B C A modeq1
  B C A df-modcon bicomi  
  sylib
)

## <title> Transitive Property </title>
thm (modcontr () () (-> (/\ (=mod A B D) (=mod A C D)) (=mod B C D))
  (mod A D) (mod B D) (mod C D) eqtr2
  A B D df-modcon bicomi  
  BiReplaceImp0An0
  A C D df-modcon bicomi    
  BiReplaceImp0An1
  B C D df-modcon bicomi    
  sylib
)

## <title> Substitution </title>
## <table>
##   (<-> ph (=  [ A ]   ]   ]  C))
##   (=          [ A ]   [ B ] )
##   (<-> ph (=  [   [   [ B ]  C))
## </table>
thm (EqReplaceBi1Eq0 () (
     replacee (<-> ph (= A C))
     substitution (= A B)) 
     (<-> ph (= B C))
  replacee substitution
  C eqeq1i
  bitri
)

## <title> Substitution </title>
## <table>
##   (<-> ph (= A  [ B ]   ]   ] ))
##   (=            [ B ]   [ C ] )
##   (<-> ph (= A  [   [   [ C ] ))
## </table>
thm (EqReplaceBi1Eq1 () (
     replacee (<-> ph (= A B))
     substitution (= B C)) 
     (<-> ph (= A C))
  replacee
  substitution
A eqeq2i
ph bibi2i
mpbi
)

thm (modcon0 () () (<-> (=mod A B (0)) (= A B))
  A B (0) df-modcon
  A mod0  
  EqReplaceBi1Eq0
  B mod0    
  EqReplaceBi1Eq1
)

thm (modval2.5 ((C x)(B x)(A x)) () (-> (= C (mod B A)) (E. x (= (+ (* A x) C) B)))
  C (mod B A) (* A x) addeq2
  B eqeq1d
  x exbid
  x A B modex
  (E. x (= (+ (* A x) C) B)) biRemove2
  (= C (mod B A)) imbi2i
  mpbi
)

## <title> Substitution </title>
## <table>
##   (-> ph (= (+  [ A ]   ]   ]  C) D))
##   (=            [ A ]   [ B ] )
##   (-> ph (= (+  [   [   [ B ]  C) D))
## </table>
thm (EqReplaceImp1Eq0Add0 () (
     replacee (-> ph (= (+ A C) D))
     substitution (= A B)) 
     (-> ph (= (+ B C) D))
  replacee substitution
  C addeq1i
  EqReplaceImp1Eq0
)

thm (addmodcon.1 () () (-> (/\ (< A C) (= A (mod B C))) (= A (mod (+ B (* C D)) C)))
  A B C x modval2.5
  (+ (* C x) A) B (* C D) addeq1  
  ## <d 'Commutative Property of Addition '>
    (+ (* C x) A) (* C D) addcom
    EqReplaceImp1Eq0
  ## </d 'Commutative Property of Addition '>  
  ## <d 'Associative Property '>
    (* C D) (* C x) A addass eqcomi
    EqReplaceImp1Eq0
  ## </d 'Associative Property '>  
  ## <d 'Commutative Property of Addition '>
    (* C D) (* C x) addcom
    EqReplaceImp1Eq0Add0
  ## </d 'Commutative Property of Addition '>  
  ## <d 'Distributive Property '>
    C x D distr eqcomi
    EqReplaceImp1Eq0Add0
  ## </d 'Distributive Property '>
  ImpReplaceImp1Ex1 

  y (+ x D) C muleq2
  A addeq1d
  (+ B (* C D)) eqeq1d
  ceqsex bicomi  
  BiReplaceImp1Ex1
  
  ## <d ''Remove Left Side of AND' '>
    (= y (+ x D)) (= (+ (* C y) A) (+ B (* C D))) pm3.27
    ImpReplaceImp1Ex1Ex1
  ## </d ''Remove Left Side of AND' '>
  ## <d 'Quantified Non-free Variable '>
    x (E. y (= (+ (* C y) A) (+ B (* C D)))) 19.9
    sylib
  ## </d 'Quantified Non-free Variable '>
  (< A C) anim2i
  A C y (+ B (* C D)) modval  
  syl
)

## <title> Substitution </title>
## <table>
##   (-> ph (<-> ps  [ ch ]   ]    ] ))
##   (->             [ ch ]   [ th ] )
##   (-> ph (<-> ps  [    [   [ th ] ))
## </table>
thm (ImpReplaceImp1Bi1 () (
     replacee (-> ph (<-> ps ch))
     substitution (-> ch th)) 
     (-> ph (-> ps th))
  replacee substitution
  ps biim2i
  syl
)

## <title> Substitution </title>
## <table>
##   (-> ph (-> ps  [ ch ]   ]    ] ))
##   (->            [ ch ]   [ th ] )
##   (-> ph (-> ps  [    [   [ th ] ))
## </table>
thm (ImpReplaceImp1Imp1 () (
     replacee (-> ph (-> ps ch))
     substitution (-> ch th)) 
     (-> ph (-> ps th))
  replacee
  substitution
ps imim2i
ph imim2i
ax-mp
)

## <title> Add any multiple of the modulus </title>
thm (addmodcon () () (-> (< (0) B) (=mod C (+ C (* B D)) B))
  B C modlt
  x (mod C B) B lteq1 
  ## <d 'Infer Right to Left '>
    (< x B) (< (mod C B) B) bi2
    syl
  ## </d 'Infer Right to Left '>
  com12  
  syl
  (= x (mod C B)) anim1d  
  ## <d 'Conjunction is Idempotent '>
    (= x (mod C B)) anidm
    BiReplaceImp1Imp0
  ## </d 'Conjunction is Idempotent '>
  x B C D addmodcon.1  
  ImpReplaceImp1Imp1
  (= x (mod C B)) (= x (mod (+ C (* B D)) B)) pm4.71  
  sylib
  ## <d 'Equality Transitive Axiom '>
    x (mod C B) (mod (+ C (* B D)) B) eqtr2
    ImpReplaceImp1Bi1
  ## </d 'Equality Transitive Axiom '>
  com12
  vtocle
  C (+ C (* B D)) B df-modcon bicomi    
  sylib
)

## <title> Add any multiple of the modulus </title>
thm (addmodcon1 () () (=mod C (+ C (* B D)) B)
  B C modlt
  x (mod C B) B lteq1
  ## <d 'Infer Right to Left '>
    (< x B) (< (mod C B) B) bi2
    syl
  ## </d 'Infer Right to Left '>
  com12
  syl
  (= x (mod C B)) anim1d
  ## <d 'Conjunction is Idempotent '>
    (= x (mod C B)) anidm
    BiReplaceImp1Imp0
  ## </d 'Conjunction is Idempotent '>
  x B C D addmodcon.1
  ImpReplaceImp1Imp1
  (= x (mod C B)) (= x (mod (+ C (* B D)) B)) pm4.71
  sylib
  ## <d 'Equality Transitive Axiom '>
    x (mod C B) (mod (+ C (* B D)) B) eqtr2
    ImpReplaceImp1Bi1
  ## </d 'Equality Transitive Axiom '>
  com12
  vtocle
  C (+ C (* B D)) B df-modcon bicomi  
  sylib
  
  ## <d 'Converse of < '>
    (0) B ltcon
    sylbi2
  ## </d 'Converse of < '>
  B (0) D muleq1  
  ## <d 'Multiply by 0 '>
    D mul0r
    EqReplaceImp1Eq1
  ## </d 'Multiply by 0 '>
  C addeq2d  
  ## <d 'Peano Axiom 3: Additive Identity Axiom '>
    C addid
    EqReplaceImp1Eq1
  ## </d 'Peano Axiom 3: Additive Identity Axiom '>
  (= B (0)) id
  C modconeq23d  
  C C modcon0
  C eqid  
  mpbirRemove
  
  (=mod C (+ C (* B D)) B) biRemove2
  (= B (0)) imbi2i
  mpbi
  jaoi  
  ## <d '≥ means > OR = '>
    B (0) gegeo bicomi
    sylbi2
  ## </d '≥ means > OR = '>
  B ge0  
  ax-mpRemove
)

## <title> Substitution </title>
## <table>
##   (-> ph (=mod A  [ B ]   ]   ]  D))
##   (=              [ B ]   [ C ] )
##   (-> ph (=mod A  [   [   [ C ]  D))
## </table>
thm (EqReplaceImp1Modcon1 () (
     replacee (-> ph (=mod A B D))
     substitution (= B C)) 
     (-> ph (=mod A C D))
  replacee substitution
  A D modconeq2i
  sylib
)

thm (addmodcon2 () () (=mod A (+ (* B C) A) B)
  A B C addmodcon1
  ## <d 'Commutative Property of Addition '>
    A (* B C) addcom
    A B modconeq2i
    mpbi
  ## </d 'Commutative Property of Addition '>
)

thm (modconex.1 () () (-> (= (+ (* A x) B) (+ (* A y) C)) (=mod C B A))
  (+ (* A x) B) (+ (* A y) C) A eqmodcon
  (+ (* A x) B) (+ (* A y) C) A B modcontr
  B A x addmodcon2 
  ## <d 'Symmetric Property '>
    B (+ (* A x) B) A modconcom
    mpbi
  ## </d 'Symmetric Property '>  
  (=mod (+ (* A x) B) (+ (* A y) C) A) anRemove2
  (=mod (+ (* A y) C) B A) imbi1i
  mpbi
  syl
  (+ (* A y) C) C A B modcontr
  C A y addmodcon2   
  ## <d 'Symmetric Property '>
    C (+ (* A y) C) A modconcom
    mpbi
  ## </d 'Symmetric Property '>  
  (=mod (+ (* A y) C) B A) anRemove1
  (=mod C B A) imbi1i
  mpbi
  syl
)

thm (modconex.2 ((A y)(B y)(C y)(A x)(B x)(C x)) () (-> (E. y (E. x (= (+ (* A x) B) (+ (* A y) C)))) (=mod C B A))
  A x B y C modconex.1
  x 19.22i
  ## <d 'Quantified Non-free Variable '>
    x (=mod C B A) 19.9
    sylib
  ## </d 'Quantified Non-free Variable '>
  y 19.22i  
  ## <d 'Quantified Non-free Variable '>
    y (=mod C B A) 19.9
    sylib
  ## </d 'Quantified Non-free Variable '>
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (=  [ A ]   ]   ]  C)))
##   (=               [ A ]   [ B ] )
##   (-> ph (E. x (=  [   [   [ B ]  C)))
## </table>
thm (EqReplaceImp1Ex1Eq0 () (
     replacee (-> ph (E. x (= A C)))
     substitution (= A B)) 
     (-> ph (E. x (= B C)))
  replacee substitution
  C eqeq1i
  BiReplaceImp1Ex1
)

## <title> Substitution </title>
## <table>
##   (-> ph (-> ps (E. x  [ ch ]   ]    ] )))
##   (<->                 [ ch ]   [ th ] )
##   (-> ph (-> ps (E. x  [    [   [ th ] )))
## </table>
thm (BiReplaceImp1Imp1Ex1 () (
     replacee (-> ph (-> ps (E. x ch)))
     substitution (<-> ch th)) 
     (-> ph (-> ps (E. x th)))
  replacee
  substitution
x exbii
ps imbi2i
ph imbi2i
mpbi
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (= (+ A  [ B ]   ]   ] ) D)))
##   (=                    [ B ]   [ C ] )
##   (-> ph (E. x (= (+ A  [   [   [ C ] ) D)))
## </table>
thm (EqReplaceImp1Ex1Eq0Add1 () (
     replacee (-> ph (E. x (= (+ A B) D)))
     substitution (= B C)) 
     (-> ph (E. x (= (+ A C) D)))
  replacee substitution
  A addeq2i
  EqReplaceImp1Ex1Eq0
)

## <title> Substitution </title>
## <table>
##   (-> ph (-> ps (E. x (E. y  [ ch ]   ]    ] ))))
##   (<->                       [ ch ]   [ th ] )
##   (-> ph (-> ps (E. x (E. y  [    [   [ th ] ))))
## </table>
thm (BiReplaceImp1Imp1Ex1Ex1 () (
     replacee (-> ph (-> ps (E. x (E. y ch))))
     substitution (<-> ch th)) 
     (-> ph (-> ps (E. x (E. y th))))
  replacee substitution
  y exbii
  BiReplaceImp1Imp1Ex1
)


## <title> Substitution </title>
## <table>
##   (-> ph (-> ps (E. x (E. y (= A  [ B ]   ]   ] )))))
##   (=                              [ B ]   [ C ] )
##   (-> ph (-> ps (E. x (E. y (= A  [   [   [ C ] )))))
## </table>
thm (EqReplaceImp1Imp1Ex1Ex1Eq1 () (
     replacee (-> ph (-> ps (E. x (E. y (= A B)))))
     substitution (= B C)) 
     (-> ph (-> ps (E. x (E. y (= A C)))))
  replacee substitution
  A eqeq2i
  BiReplaceImp1Imp1Ex1Ex1
)



## <title> Substitution </title>
## <table>
##   (-> ph (E. x (E. y (= A  [ B ]   ]   ] ))))
##   (=                       [ B ]   [ C ] )
##   (-> ph (E. x (E. y (= A  [   [   [ C ] ))))
## </table>
thm (EqReplaceImp1Ex1Ex1Eq1 () (
     replacee (-> ph (E. x (E. y (= A B))))
     substitution (= B C)) 
     (-> ph (E. x (E. y (= A C))))
  replacee substitution
  A eqeq2i
  BiReplaceImp1Ex1Ex1
)



## <title> Substitution </title>
## <table>
##   (<-> (E. x  [ ph ]   ]    ] ) ch)
##   (<->        [ ph ]   [ ps ] )
##   (<-> (E. x  [    [   [ ps ] ) ch)
## </table>
thm (BiReplaceBi0Ex1 () (
     replacee (<-> (E. x ph) ch)
     substitution (<-> ph ps)) 
     (<-> (E. x ps) ch)
  replacee substitution
  x exbii
  bitr3icom
)


## <title> Substitution </title>
## <table>
##   (<-> (E. x (E. y  [ ph ]   ]    ] )) ch)
##   (<->              [ ph ]   [ ps ] )
##   (<-> (E. x (E. y  [    [   [ ps ] )) ch)
## </table>
thm (BiReplaceBi0Ex1Ex1 () (
     replacee (<-> (E. x (E. y ph)) ch)
     substitution (<-> ph ps)) 
     (<-> (E. x (E. y ps)) ch)
  replacee substitution
  y exbii
  BiReplaceBi0Ex1
)

## <title> Modulus Congruence using Existence </title>
thm (modconex ((A y)(B y)(C y)(A x)(B x)(C x)) () (<-> (E. x (E. y (= (+ (* A x) B) (+ (* A y) C)))) (=mod B C A))
  x y A C B modconex.2

  y A B modex
  (+ (* A y) (mod B A)) B (* A x) addeq2
  (+ C (* A y)) eqeq1d
  x exbid
  (= (mod B A) (mod C A)) imbi2d
  ImpReplaceEx1

  (mod B A) C A x modval2.5
  (+ (* A x) (mod B A)) (* A y) C addcan bicomi
  BiReplaceImp1Ex1
  ## <d 'Associative Property '>
    (* A x) (mod B A) (* A y) addass
    EqReplaceImp1Ex1Eq0
  ## </d 'Associative Property '>
  ## <d 'Commutative Property of Addition '>
    (mod B A) (* A y) addcom
    EqReplaceImp1Ex1Eq0Add1
  ## </d 'Commutative Property of Addition '>
  (-> (= (mod B A) (mod C A)) (E. x (= (+ (* A x) B) (+ C (* A y))))) biRemove1
  y exbii
  mpbi
  ## <d 'Quantifier Moved Around Non-free Variable '>
    (= (mod B A) (mod C A)) y (E. x (= (+ (* A x) B) (+ C (* A y)))) imex bicomi
    mpbi
  ## </d 'Quantifier Moved Around Non-free Variable '>

  B C A df-modcon bicomi
  sylbi2
  ## <d 'Commutative Property of Addition '>
    C (* A y) addcom
    EqReplaceImp1Ex1Ex1Eq1
  ## </d 'Commutative Property of Addition '>
  ## <d 'Symmetric Property '>
    (+ (* A x) B) (+ (* A y) C) eqcom
    BiReplaceImp1Ex1Ex1
  ## </d 'Symmetric Property '>
  ## <d 'Commutativity of existential quantifiers '>
    y x (= (+ (* A y) C) (+ (* A x) B)) excom
    sylib
  ## </d 'Commutativity of existential quantifiers '>
  impbii
  
  ## <d 'Symmetric Property '>
    (+ (* A y) C) (+ (* A x) B) eqcom
    BiReplaceBi0Ex1Ex1
  ## </d 'Symmetric Property '>
)



## <title> Substitution </title>
## <table>
##   (-> ph (E. x (E. y (E. z (E. v  [ ps ]   ]    ] )))))
##   (->                             [ ps ]   [ ch ] )
##   (-> ph (E. x (E. y (E. z (E. v  [    [   [ ch ] )))))
## </table>
thm (ImpReplaceImp1Ex1Ex1Ex1Ex1 () (
     replacee (-> ph (E. x (E. y (E. z (E. v ps)))))
     substitution (-> ps ch)) 
     (-> ph (E. x (E. y (E. z (E. v ch)))))
  replacee substitution
  v 19.22i
  ImpReplaceImp1Ex1Ex1Ex1
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (E. y (E. z  [ ps ]   ]    ] ))))
##   (<->                      [ ps ]   [ ch ] )
##   (-> ph (E. x (E. y (E. z  [    [   [ ch ] ))))
## </table>
thm (BiReplaceImp1Ex1Ex1Ex1 () (
     replacee (-> ph (E. x (E. y (E. z ps))))
     substitution (<-> ps ch)) 
     (-> ph (E. x (E. y (E. z ch))))
  replacee substitution
  z exbii
  BiReplaceImp1Ex1Ex1
)


## <title> Substitution </title>
## <table>
##   (-> ph (E. x (E. y (E. z (E. v  [ ps ]   ]    ] )))))
##   (<->                            [ ps ]   [ ch ] )
##   (-> ph (E. x (E. y (E. z (E. v  [    [   [ ch ] )))))
## </table>
thm (BiReplaceImp1Ex1Ex1Ex1Ex1 () (
     replacee (-> ph (E. x (E. y (E. z (E. v ps)))))
     substitution (<-> ps ch)) 
     (-> ph (E. x (E. y (E. z (E. v ch)))))
  replacee substitution
  v exbii
  BiReplaceImp1Ex1Ex1Ex1
)

## <title> Substitution </title>
## <table>
##   (-> ph (E. x (E. y (E. z (E. v (E. w'  [ ps ]   ]    ] ))))))
##   (->                                    [ ps ]   [ ch ] )
##   (-> ph (E. x (E. y (E. z (E. v (E. w'  [    [   [ ch ] ))))))
## </table>
thm (ImpReplaceImp1Ex1Ex1Ex1Ex1Ex1 () (
     replacee (-> ph (E. x (E. y (E. z (E. v (E. w' ps))))))
     substitution (-> ps ch)) 
     (-> ph (E. x (E. y (E. z (E. v (E. w' ch))))))
  replacee substitution
  w' 19.22i
  ImpReplaceImp1Ex1Ex1Ex1Ex1
)

## <title> Add congruent numbers </title>
thm (modaddeq12 () () (-> (/\ (=mod A B j) (=mod C D j)) (=mod (+ A C) (+ B D) j))
  x y j A B modconex bicomi
  z w j C D modconex bicomi
 anbi12i
  
  ## <d 'Combine Existence Quantifiers '>
    x (E. y (= (+ (* j x) A) (+ (* j y) B))) z (E. w (= (+ (* j z) C) (+ (* j w) D))) doubleex
    ImpReplaceBi1
  ## </d 'Combine Existence Quantifiers '>
  ## <d 'Combine Existence Quantifiers '>
    y (= (+ (* j x) A) (+ (* j y) B)) w (= (+ (* j z) C) (+ (* j w) D)) doubleex
    ImpReplaceImp1Ex1Ex1
  ## </d 'Combine Existence Quantifiers '>

  ## <d 'Distributive Property '>
  (+ (* j x) A) (+ (* j y) B) (+ (* j z) C) (+ (* j w) D) addeq12
  ## <d 'Rearrange Addition Terms'>
  (* j x) A (* j z) C add4  
  EqReplaceImp1Eq0
  (* j y) B (* j w) D add4
  EqReplaceImp1Eq1
  ## </d 'Rearrange Addition Terms'>  
  ## <d 'Distributive Property '>
  ## <d 'Distributive Property '>
    j x z distr eqcomi
    EqReplaceImp1Eq0Add0
  ## </d 'Distributive Property '>
  ## <d 'Distributive Property '>
    j y w distr eqcomi
    EqReplaceImp1Eq1Add0
  ## </d 'Distributive Property '>  
  ## </d 'Distributive Property '>  
  ImpReplaceImp1Ex1Ex1Ex1Ex1
  ## </d 'Distributive Property '>

  ## <d 'Replace x + z with x"'>
  x' (+ x z) j muleq2
  (+ A C) addeq1d
  (+ (* j (+ y w)) (+ B D)) eqeq1d
  ceqsex bicomi  
  BiReplaceImp1Ex1Ex1Ex1Ex1
  ## <d ''Remove Left Side of AND' '>
    (= x' (+ x z)) (= (+ (* j x') (+ A C)) (+ (* j (+ y w)) (+ B D))) pm3.27
    ImpReplaceImp1Ex1Ex1Ex1Ex1Ex1
  ## </d ''Remove Left Side of AND' '>
  ## </d>
  ## <d 'Quantified Non-free Variables'>
  ## <d 'Quantified Non-free Variable '>
    x (E. z (E. y (E. w (E. x' (= (+ (* j x') (+ A C)) (+ (* j (+ y w)) (+ B D))))))) 19.9
    sylib
  ## </d 'Quantified Non-free Variable '>
  ## <d 'Quantified Non-free Variable '>
    z (E. y (E. w (E. x' (= (+ (* j x') (+ A C)) (+ (* j (+ y w)) (+ B D)))))) 19.9
    sylib
  ## </d 'Quantified Non-free Variable '>
  ## </d 'Quantified Non-free Variable'>

  ## <d 'Replace y + w with y"'>
  ## <d 'Replace y + w with y"'>
  y' (+ y w) j muleq2
  (+ B D) addeq1d
  (+ (* j x') (+ A C)) eqeq2d
  ceqsex bicomi  
  BiReplaceImp1Ex1Ex1Ex1  
  ## <d ''Remove Left Side of AND' '>
    (= y' (+ y w)) (= (+ (* j x') (+ A C)) (+ (* j y') (+ B D))) pm3.27
    ImpReplaceImp1Ex1Ex1Ex1Ex1
  ## </d ''Remove Left Side of AND' '>  
  ## <d 'Quantified Non-free Variable '>
    w (E. x' (E. y' (= (+ (* j x') (+ A C)) (+ (* j y') (+ B D))))) 19.9
    BiReplaceImp1Ex1
  ## </d 'Quantified Non-free Variable '>  
  ## <d 'Quantified Non-free Variable '>
    y (E. x' (E. y' (= (+ (* j x') (+ A C)) (+ (* j y') (+ B D))))) 19.9
    sylib
  ## </d 'Quantified Non-free Variable '>
  ## </d 'Replace y + w with y"'>
  ## </d 'Replace y + w with y"'>

  x' y' j (+ A C) (+ B D) modconex  
  sylib
)

## <title> Substitution </title>
## <table>
##   (= A (+ B (+ (*  [ C ]   ]   ]  A') B')))
##   (=               [ C ]   [ D ] )
##   (= A (+ B (+ (*  [   [   [ D ]  A') B')))
## </table>
thm (EqReplaceEq1Add1Add0Mul0 () (
     replacee (= A (+ B (+ (* C A') B')))
     substitution (= C D)) 
     (= A (+ B (+ (* D A') B')))
  replacee substitution
  A' muleq1i
  EqReplaceEq1Add1Add0
)

## <title> Multiply congruent numbers </title>
thm (modmuleq12 () () (-> (/\ (=mod A B j) (=mod C D j)) (=mod (* A C) (* B D) j))
  ## <d 'Modulus Congruence using Existence '>
    x y j A B modconex bicomi
    z w j C D modconex bicomi
    anbi12i
  ## </d>
  
  ## <d 'Combine Existence Quantifiers '>
  ## <d 'Combine Existence Quantifiers '>
    x (E. y (= (+ (* j x) A) (+ (* j y) B))) z (E. w (= (+ (* j z) C) (+ (* j w) D))) doubleex
    ImpReplaceBi1
  ## </d 'Combine Existence Quantifiers '>
  ## <d 'Combine Existence Quantifiers '>
    y (= (+ (* j x) A) (+ (* j y) B)) w (= (+ (* j z) C) (+ (* j w) D)) doubleex
    ImpReplaceImp1Ex1Ex1
  ## </d 'Combine Existence Quantifiers '>
  ## </d 'Combine Existence Quantifiers '>

  ## <d 'Distributive Property '>
    (+ (* j x) A) (+ (* j y) B) (+ (* j z) C) (+ (* j w) D) muleq12   
  
    ## <d 'Distributive Property '>
      (* j y) B (+ (* j w) D) distl
    ## </d 'Distributive Property '>
    ## <d 'Distributive Property '>
      B (* j w) D distr
      EqReplaceEq1Add1
    ## </d 'Distributive Property '>
    ## <d 'Associative Property '>
      B j w mulass eqcomi
      EqReplaceEq1Add1Add0
    ## </d 'Associative Property '>
    ## <d 'Commutative Property '>
      B j mulcom
      EqReplaceEq1Add1Add0Mul0
    ## </d 'Commutative Property '>
  
    ## <d 'Associative Property '>
      (* (* j y) (+ (* j w) D)) (* (* j B) w) (* B D) addass eqcomi
      EqReplaceEq1
    ## </d 'Associative Property '>
    ## <d 'Associative Property '>
      j y (+ (* j w) D) mulass
      EqReplaceEq1Add0Add0
    ## </d 'Associative Property '>
    ## <d 'Associative Property '>
      j B w mulass
      EqReplaceEq1Add0Add1
    ## </d 'Associative Property '>
    ## <d 'Distributive Property '>
      j (* y (+ (* j w) D)) (* B w) distr eqcomi
      EqReplaceEq1Add0
    ## </d 'Distributive Property '>
  
    EqReplaceImp1Eq1   
  
  ## <d 'Distributive Property '>
    ## <d 'Distributive Property '>
      (* j x) A (+ (* j z) C) distl
    ## </d 'Distributive Property '>
    ## <d 'Associative Property '>
      j x (+ (* j z) C) mulass
      EqReplaceEq1Add0
    ## </d 'Associative Property '>
    ## <d 'Distributive Property '>
      A (* j z) C distr
      EqReplaceEq1Add1
    ## </d 'Distributive Property '>
    ## <d 'Associative Property '>
      A j z mulass eqcomi
      EqReplaceEq1Add1Add0
    ## </d 'Associative Property '>
    ## <d 'Commutative Property '>
      A j mulcom
      EqReplaceEq1Add1Add0Mul0
    ## </d 'Commutative Property '>
    ## <d 'Associative Property '>
      j A z mulass
      EqReplaceEq1Add1Add0
    ## </d 'Associative Property '>
    ## <d 'Associative Property '>
      (* j (* x (+ (* j z) C))) (* j (* A z)) (* A C) addass eqcomi
      EqReplaceEq1
    ## </d 'Associative Property '>  
    ## <d 'Distributive Property '>
      j (* x (+ (* j z) C)) (* A z) distr eqcomi
      EqReplaceEq1Add0
    ## </d 'Distributive Property '>
    EqReplaceImp1Eq0
    ImpReplaceImp1Ex1Ex1Ex1Ex1
  ## </d 'Distributive Property '>
  ## </d 'Distributive Property '>
  ## <d 'Replace x and z expression with x" '>
  x' (+ (* x (+ (* j z) C)) (* A z)) j muleq2
  (* A C) addeq1d
  (+ (* j (+ (* y (+ (* j w) D)) (* B w))) (* B D)) eqeq1d
  ceqsex bicomi  
  BiReplaceImp1Ex1Ex1Ex1Ex1
  
  ## <d 'Remove Left Side of AND '>
    (= x' (+ (* x (+ (* j z) C)) (* A z))) (= (+ (* j x') (* A C)) (+ (* j (+ (* y (+ (* j w) D)) (* B w))) (* B D))) pm3.27
    ImpReplaceImp1Ex1Ex1Ex1Ex1Ex1
  ## </d 'Remove Left Side of AND '>  
  ## <d 'Quantified Non-free Variable '>
    x (E. z (E. y (E. w (E. x' (= (+ (* j x') (* A C)) (+ (* j (+ (* y (+ (* j w) D)) (* B w))) (* B D))))))) 19.9
    sylib
  ## </d 'Quantified Non-free Variable '>  
  ## <d 'Quantified Non-free Variable '>
    z (E. y (E. w (E. x' (= (+ (* j x') (* A C)) (+ (* j (+ (* y (+ (* j w) D)) (* B w))) (* B D)))))) 19.9
    sylib
  ## </d 'Quantified Non-free Variable '>
  ## </d 'Replace x and z expression with x" '>

  ## <d 'Replace y and w expression with y" '>
  y' (+ (* y (+ (* j w) D)) (* B w)) j muleq2
  (* B D) addeq1d
  (+ (* j x') (* A C)) eqeq2d
  ceqsex bicomi    
  BiReplaceImp1Ex1Ex1Ex1
  
  ## <d 'Remove Left Side of AND '>
    (= y' (+ (* y (+ (* j w) D)) (* B w))) (= (+ (* j x') (* A C)) (+ (* j y') (* B D))) pm3.27
    ImpReplaceImp1Ex1Ex1Ex1Ex1
  ## </d 'Remove Left Side of AND '>  
  ## <d 'Quantified Non-free Variable '>
    w (E. x' (E. y' (= (+ (* j x') (* A C)) (+ (* j y') (* B D))))) 19.9
    BiReplaceImp1Ex1
  ## </d 'Quantified Non-free Variable '>  
  ## <d 'Quantified Non-free Variable '>
    y (E. x' (E. y' (= (+ (* j x') (* A C)) (+ (* j y') (* B D))))) 19.9
    sylib
  ## </d 'Quantified Non-free Variable '>
  ## </d 'Replace y and w expression with y" '>
  
  x' y' j (* A C) (* B D) modconex  
  sylib
)

## <summary> This is used just for convenience to get an empty theorem. </summary>
thm (emptyThm () () (T)
 tru
)

export (MIN_MOD_DIV min_mod_div.ghi (PROP PREDICATE NATURALS SET_MIN) "")
